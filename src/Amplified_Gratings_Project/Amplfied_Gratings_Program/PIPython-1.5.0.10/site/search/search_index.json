{
    "docs": [
        {
            "location": "/index.html", 
            "text": "PIPython\n\n\nPIPython is a collection of Python modules to access a PI device and process\nGCS data. It can be used with Python 2.7+ and 3.4+ on Windows, Linux and OS X\nand without the GCS DLL also on any other platform.\n\n\nQuickstart\n\n\nCommunicate to a PI device via \nGCSDevice\n which wraps the GCS DLL functions\nand provides methods to connect to the device. Call \nGCSDevice\n with the\ncontroller name as argument.\n\n\nfrom pipython import GCSDevice\ngcs = GCSDevice('C-884')\npidevice.InterfaceSetupDlg()\nprint pidevice.qIDN()\npidevice.CloseConnection()\n\n\n\n\nGCSDevice\n is a context manager which closes the connection if an exception\nraises inside the \nwith\n statement.\n\n\nfrom pipython import GCSDevice\nwith GCSDevice('C-884') as gcs:\n    pidevice.InterfaceSetupDlg()\n    print(pidevice.qIDN())\n\n\n\n\nSee also the provided samples in the \nsamples\n subdirectory. Start with \nquickstart.py\n.\n\n\nRequirements\n\n\nThere are no dependencies to additional packages.\n\n\nWith pipython.interfaces.piusb you can connect a USB device without using the GCS DLL.\nThis works only with Linux and requires LibUSB which usually is provided by the OS.\n\n\nArguments\n\n\nFrom now on \npidevice\n refers to a connected \nGCSDevice\n instance.\n\n\nYou can call a setter function with:\n\n\n\n\na dictionary of axes/channels and values\n\n\na list for axes/channels and a list of the values\n\n\na single item for axis/channel and a single value\n\n\n\n\npidevice.MOV({'X': 1.23, 'Y': 2.34})\npidevice.MOV(['X', 'Y'], [1.23, 2.34])\npidevice.MOV('X', 1.23)\n\n\n\n\nFor channels and numeric axis names you can omit the quotes.\n\n\npidevice.MOV({1: 1.23, 2: 2.34})\npidevice.MOV([1, 2], [1.23, 2.34])\npidevice.MOV(1, 1.23)\n\n\n\n\nGetter commands can be called with:\n\n\n\n\na list of axes/channels\n\n\na single item for axis/channel, without quotes if numeric\n\n\nwithout any arguments which will return the answer for all available axes/channels\n\n\n\n\npidevice.qPOS(['X', 'Y'])\npidevice.qPOS('X')\npidevice.qPOS(1)\npidevice.qPOS()\n\n\n\n\nReturn values\n\n\nAxes or channel related answers are returned as (ordered) dictionary.\n\n\npidevice.qPOS()\n\n{'X': 1.23, 'Y': 2.34}\n\n\n\n\nIf you provide arguments their types are preserved and you can use these as keys.\n\n\npos = pidevice.qPOS([1, 2, 3])\nprint(pos[1])\n\n\n\n\nIf you do not provide arguments you always have to use strings as keys.\n\n\npos = pidevice.qPOS()\nprint(pos['1'])\n\n\n\n\nThe following sample will move all \naxes\n to \ntargets\n and waits until the motion has finished.\nIt shows how to use only the values from the returned dictionary.\n\n\nfrom time import sleep\n...\npidevice.MOV(axes, targets)\nwhile not all(list(pidevice.qONT(axes).values())):\n    sleep(0.1)\n\n\n\n\nSome hints...\n\n\nHelpers\n\n\nIn \npipython.pitools\n you will find some helper funtions for your convenience. See the provided\nsamples for how to use them. The sample above can then be written as:\n\n\nfrom pipython import pitools\n...\npidevice.MOV(axes, targets)\npitools.waitontarget(pidevice, axes)\n\n\n\n\nEnable debug logging\n\n\nTo log debug messages on the console just enter these lines prior to calling \nGCSDevice\n.\n\n\nfrom logging import basicConfig, DEBUG\nbasicConfig(level=DEBUG)\n\n\n\n\nGCSError and error check\n\n\nBy default an \"ERR?\" command is sent after each command to query if an error\noccurred on the device which then will be raised as \nGCSError\n exception. If communication\nspeed is an issue you can disable error checking.\n\n\npidevice.errcheck = False\n\n\n\n\nTo handle a catched \nGCSError\n exception you can use the defines provided by\n\ngcserror\n instead of pure numeric values. Remember the difference between \nGCSError\n which\nis the exception class and \ngcserror\n which is the according module.\n\n\nfrom pipython import GCSDevice, GCSError, gcserror\nwith GCSDevice('C-884') as pidevice:\n    try:\n        pidevice.MOV('X', 1.23)\n    except GCSError as exc:\n        if exc == gcserror.E_1024_PI_MOTION_ERROR:\n            print('There was a motion error, please check the mechanics.')\n        else:\n            raise\n\n\n\n\nThe exception class \nGCSError\n will translate the error code into a readable message.\n\n\nfrom pipython import GCSError, gcserror\nraise GCSError(gcserror.E_1024_PI_MOTION_ERROR)\n\nGCSError: Motion error: position error too large, servo is switched off automatically (-1024)\n\n\n\n\nBig data\n\n\nCommands like \nqDRR()\n which read a large amount of GCS data return immediately with\nthe header dictionary containing information about the data. Then they will start\na background task that carries on reading data from the device into an internal buffer. The\n\nbufstate\n property returns the progress of the reading as floating point number in the range\n0 to 1 and turns to \nTrue\n when reading has finished. Hence, when using it in a loop check for\n\nis not True\n. (Remember, this is not the same as \n!= True\n.)\n\n\nheader = pidevice.qDRR(1, 1, 8192)\nwhile pidevice.bufstate is not True:\n    print('read data {:.1f}%...'.format(pidevice.bufstate * 100))\n    sleep(0.1)\ndata = pidevice.bufdata\n\n\n\n\nTextual interface\n\n\nBesides the functions implemented in GCSCommands you can send GCS commands as strings to the\ncontroller. Use \nread()\n for commands returning an answer, \nread_gcsdata()\n for commands returning\nGCS data and \nsend()\n for non-answering commands.\n\n\nprint(pidevice.read('POS?'))\nprint(pidevice.read_gcsdata('DRR? 1 100 1'))\npidevice.send('MOV X 1.23')\n\n\n\n\nThey return the raw string or GCS data from the controller. If \nerrorcheck\n is enabled the\nerror state is queried from the device automatically. We recommend to use the provided\nfunctions instead of sending raw strings.\n\n\nIn line with the C++ GCS DLL the functions \nReadGCSCommand()\n and \nGcsCommandset()\n are also\navailable. They will never query an error from the device.\n\n\nprint(pidevice.ReadGCSCommand('POS?'))\npidevice.GcsCommandset('MOV X 1.23')", 
            "title": "Home"
        }, 
        {
            "location": "/index.html#pipython", 
            "text": "PIPython is a collection of Python modules to access a PI device and process\nGCS data. It can be used with Python 2.7+ and 3.4+ on Windows, Linux and OS X\nand without the GCS DLL also on any other platform.", 
            "title": "PIPython"
        }, 
        {
            "location": "/index.html#quickstart", 
            "text": "Communicate to a PI device via  GCSDevice  which wraps the GCS DLL functions\nand provides methods to connect to the device. Call  GCSDevice  with the\ncontroller name as argument.  from pipython import GCSDevice\ngcs = GCSDevice('C-884')\npidevice.InterfaceSetupDlg()\nprint pidevice.qIDN()\npidevice.CloseConnection()  GCSDevice  is a context manager which closes the connection if an exception\nraises inside the  with  statement.  from pipython import GCSDevice\nwith GCSDevice('C-884') as gcs:\n    pidevice.InterfaceSetupDlg()\n    print(pidevice.qIDN())  See also the provided samples in the  samples  subdirectory. Start with  quickstart.py .", 
            "title": "Quickstart"
        }, 
        {
            "location": "/index.html#requirements", 
            "text": "There are no dependencies to additional packages.  With pipython.interfaces.piusb you can connect a USB device without using the GCS DLL.\nThis works only with Linux and requires LibUSB which usually is provided by the OS.", 
            "title": "Requirements"
        }, 
        {
            "location": "/index.html#arguments", 
            "text": "From now on  pidevice  refers to a connected  GCSDevice  instance.  You can call a setter function with:   a dictionary of axes/channels and values  a list for axes/channels and a list of the values  a single item for axis/channel and a single value   pidevice.MOV({'X': 1.23, 'Y': 2.34})\npidevice.MOV(['X', 'Y'], [1.23, 2.34])\npidevice.MOV('X', 1.23)  For channels and numeric axis names you can omit the quotes.  pidevice.MOV({1: 1.23, 2: 2.34})\npidevice.MOV([1, 2], [1.23, 2.34])\npidevice.MOV(1, 1.23)  Getter commands can be called with:   a list of axes/channels  a single item for axis/channel, without quotes if numeric  without any arguments which will return the answer for all available axes/channels   pidevice.qPOS(['X', 'Y'])\npidevice.qPOS('X')\npidevice.qPOS(1)\npidevice.qPOS()", 
            "title": "Arguments"
        }, 
        {
            "location": "/index.html#return-values", 
            "text": "Axes or channel related answers are returned as (ordered) dictionary.  pidevice.qPOS() {'X': 1.23, 'Y': 2.34}  If you provide arguments their types are preserved and you can use these as keys.  pos = pidevice.qPOS([1, 2, 3])\nprint(pos[1])  If you do not provide arguments you always have to use strings as keys.  pos = pidevice.qPOS()\nprint(pos['1'])  The following sample will move all  axes  to  targets  and waits until the motion has finished.\nIt shows how to use only the values from the returned dictionary.  from time import sleep\n...\npidevice.MOV(axes, targets)\nwhile not all(list(pidevice.qONT(axes).values())):\n    sleep(0.1)", 
            "title": "Return values"
        }, 
        {
            "location": "/index.html#some-hints", 
            "text": "", 
            "title": "Some hints..."
        }, 
        {
            "location": "/index.html#helpers", 
            "text": "In  pipython.pitools  you will find some helper funtions for your convenience. See the provided\nsamples for how to use them. The sample above can then be written as:  from pipython import pitools\n...\npidevice.MOV(axes, targets)\npitools.waitontarget(pidevice, axes)", 
            "title": "Helpers"
        }, 
        {
            "location": "/index.html#enable-debug-logging", 
            "text": "To log debug messages on the console just enter these lines prior to calling  GCSDevice .  from logging import basicConfig, DEBUG\nbasicConfig(level=DEBUG)", 
            "title": "Enable debug logging"
        }, 
        {
            "location": "/index.html#gcserror-and-error-check", 
            "text": "By default an \"ERR?\" command is sent after each command to query if an error\noccurred on the device which then will be raised as  GCSError  exception. If communication\nspeed is an issue you can disable error checking.  pidevice.errcheck = False  To handle a catched  GCSError  exception you can use the defines provided by gcserror  instead of pure numeric values. Remember the difference between  GCSError  which\nis the exception class and  gcserror  which is the according module.  from pipython import GCSDevice, GCSError, gcserror\nwith GCSDevice('C-884') as pidevice:\n    try:\n        pidevice.MOV('X', 1.23)\n    except GCSError as exc:\n        if exc == gcserror.E_1024_PI_MOTION_ERROR:\n            print('There was a motion error, please check the mechanics.')\n        else:\n            raise  The exception class  GCSError  will translate the error code into a readable message.  from pipython import GCSError, gcserror\nraise GCSError(gcserror.E_1024_PI_MOTION_ERROR) GCSError: Motion error: position error too large, servo is switched off automatically (-1024)", 
            "title": "GCSError and error check"
        }, 
        {
            "location": "/index.html#big-data", 
            "text": "Commands like  qDRR()  which read a large amount of GCS data return immediately with\nthe header dictionary containing information about the data. Then they will start\na background task that carries on reading data from the device into an internal buffer. The bufstate  property returns the progress of the reading as floating point number in the range\n0 to 1 and turns to  True  when reading has finished. Hence, when using it in a loop check for is not True . (Remember, this is not the same as  != True .)  header = pidevice.qDRR(1, 1, 8192)\nwhile pidevice.bufstate is not True:\n    print('read data {:.1f}%...'.format(pidevice.bufstate * 100))\n    sleep(0.1)\ndata = pidevice.bufdata", 
            "title": "Big data"
        }, 
        {
            "location": "/index.html#textual-interface", 
            "text": "Besides the functions implemented in GCSCommands you can send GCS commands as strings to the\ncontroller. Use  read()  for commands returning an answer,  read_gcsdata()  for commands returning\nGCS data and  send()  for non-answering commands.  print(pidevice.read('POS?'))\nprint(pidevice.read_gcsdata('DRR? 1 100 1'))\npidevice.send('MOV X 1.23')  They return the raw string or GCS data from the controller. If  errorcheck  is enabled the\nerror state is queried from the device automatically. We recommend to use the provided\nfunctions instead of sending raw strings.  In line with the C++ GCS DLL the functions  ReadGCSCommand()  and  GcsCommandset()  are also\navailable. They will never query an error from the device.  print(pidevice.ReadGCSCommand('POS?'))\npidevice.GcsCommandset('MOV X 1.23')", 
            "title": "Textual interface"
        }, 
        {
            "location": "/connect/index.html", 
            "text": "Device connection\n\n\nHere you will find sample code for how to connect one ore more PI devices. For further reading see the python scripts in the \nsamples\n subdirectory.\n\n\nConnect a single device via the GCS DLL\n\n\nBy a dialog\n\n\nOn Windows systems the GCS DLL provides a graphical user interface to select the interface and parameters.\n\n\nfrom pipython import GCSDevice\nwith GCSDevice() as gcs:\n    gcs.InterfaceSetupDlg()\n    print('connected: {}'.format(gcs.qIDN().strip()))\n\n\n\n\nIf you pass an optional \nkey\n as arbitrary string to the \nInterfaceSetupDlg\n method, the DLL remembers the settings in the Windows registry and will recall them the next time you connect with the same key.\n\n\nfrom pipython import GCSDevice\nwith GCSDevice() as gcs:\n    gcs.InterfaceSetupDlg('MyTest')\n    print('connected: {}'.format(gcs.qIDN().strip()))\n\n\n\n\nBy a dedicated interface\n\n\nYou can connect via these interfaces with the according methods.\n\n\n\n\nRS-232: \nConnectRS232(comport, baudrate)\n\n\nUSB: \nConnectUSB(serialnum)\n\n\nTCP/IP: \nConnectTCPIP(ipaddress, ipport=50000)\n\n\nTCP/IP: \nConnectTCPIPByDescription(description)\n\n\nNI GPIB: \nConnectNIgpib(board, device)\n\n\nPCI board: \nConnectPciBoard(board)\n\n\n\n\nfrom pipython import GCSDevice\nwith GCSDevice() as gcs:\n    gcs.ConnectTCPIP('192.168.178.42')\n    print('connected: {}'.format(gcs.qIDN().strip()))\n\n\n\n\nThe parameter \nserialnum\n can be the serial number of the device as string or the device\nidentification returned by \nEnumerateUSB\n. For TCP/IP \nConnectTCPIP\n connects by given\nIP address where \nConnectTCPIPByDescription\n uses the string from \nEnumerateTCPIPDevices\n.\n\n\nBy the device identification\n\n\nThere are functions to scan for available devices.\n\n\n\n\nUSB: \nEnumerateUSB(mask='')\n\n\nTCPIP: \nEnumerateTCPIPDevices(mask='')\n\n\n\n\nUse the \nmask\n to limit the number of found devices. It is a string that must\nbe part of the identification string - see \nqIDN\n - returned by the devices.\n\n\nfrom pipython import GCSDevice\nwith GCSDevice() as gcs:\n    devices = gcs.EnumerateTCPIPDevices(mask='C-884.4DB')\n    for i, device in enumerate(devices):\n        print('{} - {}'.format(i, device))\n    item = int(input('Select device to connect:'))\n    gcs.ConnectTCPIPByDescription(devices[item])\n    print('connected: {}'.format(gcs.qIDN().strip()))\n\n\n\n\nConnect daisy chain devices\n\n\nYou have to open the interface once and than you connect all devices to this interface. Each\ndevice must have a unique ID on the daisy chain (see controller manual). There must be one\ndevice with ID1 which needs not to be the master device (i.e. connected to the PC). See an\nexample for 3 devices on an RS-232 daisy chain.\n\n\n\n\nC-863 controller with device ID 3, this is the master device\n\n\nE-861 controller with device ID 7\n\n\nC-867 controller with device ID 1\n\n\n\n\nThere is no need to close the connections. This is done automatically because \nGCSDevice\n\nis used as context manager.\n\n\nfrom pipython import GCSDevice\nwith GCSDevice() as c863:\n    c863.OpenRS232DaisyChain(comport=1, baudrate=115200)\n    # c863.OpenUSBDaisyChain(description='1234567890')\n    # c863.OpenTCPIPDaisyChain(ipaddress='192.168.178.42')\n    daisychainid = c863.dcid\n    c863.ConnectDaisyChainDevice(3, daisychainid)\n    with GCSDevice() as e861:\n        e861.ConnectDaisyChainDevice(7, daisychainid)\n        with GCSDevice() as c867:\n            c867.ConnectDaisyChainDevice(1, daisychainid)\n            print('\\n{}:\\n{}'.format(c863.GetInterfaceDescription(), c863.qIDN()))\n            print('\\n{}:\\n{}'.format(e861.GetInterfaceDescription(), e861.qIDN()))\n            print('\\n{}:\\n{}'.format(c867.GetInterfaceDescription(), c867.qIDN()))\n\n\n\n\nLow level interface\n\n\nUsually you connect with \nGCSDevice\n via the GCS DLL. But on platforms where the GCS DLL is\nnot available you are still able to connect.\n\n\nBy PISocket:\n\n\nfrom pipython.gcscommands import GCSCommands\nfrom pipython.gcsmessages import GCSMessages\nfrom pipython.interfaces.pisocket import PISocket\nwith PISocket(host='192.168.178.42', port=50000) as gateway:\n    messages = GCSMessages(gateway)\n    gcs = GCSCommands(messages)\n    print(gcs.qIDN())\n\n\n\n\nBy PISerial:\n\n\nfrom pipython.gcscommands import GCSCommands\nfrom pipython.gcsmessages import GCSMessages\nfrom pipython.interfaces.piserial import PISerial\nwith PISerial(port=1, baudrate=115200) as gateway:\n    messages = GCSMessages(gateway)\n    gcs = GCSCommands(messages)\n    print(gcs.qIDN())\n\n\n\n\nBy PIUSB:\n\n\nThis interface requires LibUSB which usually is only available on Linux like operation systems.\nHint: Run \npip install pyusb\n.\n\n\nfrom pipython.gcscommands import GCSCommands\nfrom pipython.gcsmessages import GCSMessages\nfrom pipython.interfaces.piusb import PIUSB\nwith PIUSB() as gateway:\n    gateway.connect(serialnumber='1234567890', pid=0x1234)\n    messages = GCSMessages(gateway)\n    gcs = GCSCommands(messages)\n    print(gcs.qIDN())\n\n\n\n\nUnknown devices\n\n\nWhen you call \nGCSDevice\n with the controller name the according GCS DLL is chosen automatically.\nFor unknown devices you can specify a dedicated GCS DLL instead.\n\n\nfrom pipython import GCSDevice\nwith GCSDevice(gcsdll='PI_GCS2_DLL.dll') as gcs:\n    gcs.InterfaceSetupDlg()", 
            "title": "Device Connection"
        }, 
        {
            "location": "/connect/index.html#device-connection", 
            "text": "Here you will find sample code for how to connect one ore more PI devices. For further reading see the python scripts in the  samples  subdirectory.", 
            "title": "Device connection"
        }, 
        {
            "location": "/connect/index.html#connect-a-single-device-via-the-gcs-dll", 
            "text": "", 
            "title": "Connect a single device via the GCS DLL"
        }, 
        {
            "location": "/connect/index.html#by-a-dialog", 
            "text": "On Windows systems the GCS DLL provides a graphical user interface to select the interface and parameters.  from pipython import GCSDevice\nwith GCSDevice() as gcs:\n    gcs.InterfaceSetupDlg()\n    print('connected: {}'.format(gcs.qIDN().strip()))  If you pass an optional  key  as arbitrary string to the  InterfaceSetupDlg  method, the DLL remembers the settings in the Windows registry and will recall them the next time you connect with the same key.  from pipython import GCSDevice\nwith GCSDevice() as gcs:\n    gcs.InterfaceSetupDlg('MyTest')\n    print('connected: {}'.format(gcs.qIDN().strip()))", 
            "title": "By a dialog"
        }, 
        {
            "location": "/connect/index.html#by-a-dedicated-interface", 
            "text": "You can connect via these interfaces with the according methods.   RS-232:  ConnectRS232(comport, baudrate)  USB:  ConnectUSB(serialnum)  TCP/IP:  ConnectTCPIP(ipaddress, ipport=50000)  TCP/IP:  ConnectTCPIPByDescription(description)  NI GPIB:  ConnectNIgpib(board, device)  PCI board:  ConnectPciBoard(board)   from pipython import GCSDevice\nwith GCSDevice() as gcs:\n    gcs.ConnectTCPIP('192.168.178.42')\n    print('connected: {}'.format(gcs.qIDN().strip()))  The parameter  serialnum  can be the serial number of the device as string or the device\nidentification returned by  EnumerateUSB . For TCP/IP  ConnectTCPIP  connects by given\nIP address where  ConnectTCPIPByDescription  uses the string from  EnumerateTCPIPDevices .", 
            "title": "By a dedicated interface"
        }, 
        {
            "location": "/connect/index.html#by-the-device-identification", 
            "text": "There are functions to scan for available devices.   USB:  EnumerateUSB(mask='')  TCPIP:  EnumerateTCPIPDevices(mask='')   Use the  mask  to limit the number of found devices. It is a string that must\nbe part of the identification string - see  qIDN  - returned by the devices.  from pipython import GCSDevice\nwith GCSDevice() as gcs:\n    devices = gcs.EnumerateTCPIPDevices(mask='C-884.4DB')\n    for i, device in enumerate(devices):\n        print('{} - {}'.format(i, device))\n    item = int(input('Select device to connect:'))\n    gcs.ConnectTCPIPByDescription(devices[item])\n    print('connected: {}'.format(gcs.qIDN().strip()))", 
            "title": "By the device identification"
        }, 
        {
            "location": "/connect/index.html#connect-daisy-chain-devices", 
            "text": "You have to open the interface once and than you connect all devices to this interface. Each\ndevice must have a unique ID on the daisy chain (see controller manual). There must be one\ndevice with ID1 which needs not to be the master device (i.e. connected to the PC). See an\nexample for 3 devices on an RS-232 daisy chain.   C-863 controller with device ID 3, this is the master device  E-861 controller with device ID 7  C-867 controller with device ID 1   There is no need to close the connections. This is done automatically because  GCSDevice \nis used as context manager.  from pipython import GCSDevice\nwith GCSDevice() as c863:\n    c863.OpenRS232DaisyChain(comport=1, baudrate=115200)\n    # c863.OpenUSBDaisyChain(description='1234567890')\n    # c863.OpenTCPIPDaisyChain(ipaddress='192.168.178.42')\n    daisychainid = c863.dcid\n    c863.ConnectDaisyChainDevice(3, daisychainid)\n    with GCSDevice() as e861:\n        e861.ConnectDaisyChainDevice(7, daisychainid)\n        with GCSDevice() as c867:\n            c867.ConnectDaisyChainDevice(1, daisychainid)\n            print('\\n{}:\\n{}'.format(c863.GetInterfaceDescription(), c863.qIDN()))\n            print('\\n{}:\\n{}'.format(e861.GetInterfaceDescription(), e861.qIDN()))\n            print('\\n{}:\\n{}'.format(c867.GetInterfaceDescription(), c867.qIDN()))", 
            "title": "Connect daisy chain devices"
        }, 
        {
            "location": "/connect/index.html#low-level-interface", 
            "text": "Usually you connect with  GCSDevice  via the GCS DLL. But on platforms where the GCS DLL is\nnot available you are still able to connect.", 
            "title": "Low level interface"
        }, 
        {
            "location": "/connect/index.html#by-pisocket", 
            "text": "from pipython.gcscommands import GCSCommands\nfrom pipython.gcsmessages import GCSMessages\nfrom pipython.interfaces.pisocket import PISocket\nwith PISocket(host='192.168.178.42', port=50000) as gateway:\n    messages = GCSMessages(gateway)\n    gcs = GCSCommands(messages)\n    print(gcs.qIDN())", 
            "title": "By PISocket:"
        }, 
        {
            "location": "/connect/index.html#by-piserial", 
            "text": "from pipython.gcscommands import GCSCommands\nfrom pipython.gcsmessages import GCSMessages\nfrom pipython.interfaces.piserial import PISerial\nwith PISerial(port=1, baudrate=115200) as gateway:\n    messages = GCSMessages(gateway)\n    gcs = GCSCommands(messages)\n    print(gcs.qIDN())", 
            "title": "By PISerial:"
        }, 
        {
            "location": "/connect/index.html#by-piusb", 
            "text": "This interface requires LibUSB which usually is only available on Linux like operation systems.\nHint: Run  pip install pyusb .  from pipython.gcscommands import GCSCommands\nfrom pipython.gcsmessages import GCSMessages\nfrom pipython.interfaces.piusb import PIUSB\nwith PIUSB() as gateway:\n    gateway.connect(serialnumber='1234567890', pid=0x1234)\n    messages = GCSMessages(gateway)\n    gcs = GCSCommands(messages)\n    print(gcs.qIDN())", 
            "title": "By PIUSB:"
        }, 
        {
            "location": "/connect/index.html#unknown-devices", 
            "text": "When you call  GCSDevice  with the controller name the according GCS DLL is chosen automatically.\nFor unknown devices you can specify a dedicated GCS DLL instead.  from pipython import GCSDevice\nwith GCSDevice(gcsdll='PI_GCS2_DLL.dll') as gcs:\n    gcs.InterfaceSetupDlg()", 
            "title": "Unknown devices"
        }, 
        {
            "location": "/datarecorder/index.html", 
            "text": "Data recorder\n\n\nA PI device has one or more record tables that can be filled with\nfloat values (i.e. numbers). The typical workflow is as following.\n\n\n\n\nSet the record rate.\n\n\nConfigure the data to be recorded.\n\n\nConfigure the trigger event that starts the recorder.\n\n\nPerform the action that should be recorded.\n\n\nWait until the action is finished.\n\n\nWait until the data has been recorded.\n\n\nStart reading out the data from the controller.\n\n\nWait until all data has been read out from the device.\n\n\nProcess the data.\n\n\n\n\nPlease find an according sample in \nsamples/datarecorder.py\n.\n\n\nPrepare the data recorder\n\n\nSet the record rate\n\n\nWith the GCS command \nRTR\n you can set the record rate in multiples of\nthe device specific servo loop time. Hence the higher the RTR rate is the\nslower the data is recorded. For your convenience the Datarecorder() class\ntakes a record rate in Hertz and seconds, too.\n\n\nfrom pipython import GCSDevice\nfrom pipython import datarectools, pitools\ngcs = GCSDevice()\ngcs.InterfaceSetupDlg()\n...\ndrec = datarectools.Datarecorder(gcs)\n# drec.samplerate = 1  # servo cycles\n# drec.sampletime = 1E-5  # seconds\ndrec.samplefrequ = 1000  # Hertz\nprint('data recorder rate: {:d} servo cycles'.format(drec.samplerate))\nprint('data recorder rate: {:.g} seconds'.format(drec.sampletime))\nprint('data recorder rate: {:.2f} Hertz'.format(drec.samplefrequ))\n\n\n\n\nSet the record time\n\n\nBy default the entire data recorder memory is used to record the data.\nYou can reduce the number of points with the \nnumvalues\n property. Or\nyou set the time to record in seconds with \nrectime\n which adjusts\n\nnumvalues\n accordingly. The \nrectimemax\n property will use the entire\ndata recorder memory and will adjust the \nsamplerate\n accordingly.\n\n\nFurther on \ngcs\n is referred as instance of pipython.GCSDevice and \ndrec\n\nis referred as instance of pipython.datarectools.Datarecorder.\n\n\nConfigure data recorder\n\n\nWith the GCS command \nDRC\n you can configure which measurement\n(the \nrecord option\n) of which \nrecord source\n (e.g. an axis\nor channel) is recorded in a specified \nrecord table\n.\n\n\nThere is an enumeration \npipython.datarectools.RecordOptions\n available.\n\n\nThe function \nDatarecorder.record()\n takes one\nor more \naxes\n, one or more \nrecord options\n and one or more\n\ntrigger options\n. If you call it with a single axis and several\n\nrecord options\n it will take the given axis for all recordings.\nAnd vice versa it will take a single \nrecord option\n for several\ngiven \naxes\n. When you omit the \naxes\n argument all connected\naxes are taken. If you omit the \nrecord option\n then\n\nRecordOptions.ACTUAL_POSITION_2\n is taken.\nIt will return a list of record table IDs where the desired data\nwill be stored. See the example code below.\n\n\nConfigure the trigger event\n\n\nWith the GCS command \nDRT\n you can configure when the recording will\nstart, e.g. \nimmediately\n or with the \nnext command that changes a\nposition\n, i.e. that makes a motion.\n\n\nThere is an enumeration \npipython.datarectools.TriggerSources\n available.\n\n\nIf you call the function Datarecorder.record() with\na single value as \ntrigger option\n it will use the \nDRT\n command\nwith the record table \"0\". If it is called with a list as argument it\nwill use \nDRT\n with the according record table IDs. See the controller\nuser manual which is the appropriate way for your device.\nIf you omit the \ntrigger options\n argument then\n\nTriggerSources.NEXT_COMMAND_WITH_RESET_2\n is taken.\nIf \nTriggerSources.NEXT_COMMAND_WITH_RESET_2\n is used then the error\ncheck will be disabled automatically.\n\n\nThe following sample will configure two recordings of one axis\ntriggered by a position changing command and arm the data recorder.\n\n\ndrec.options = (datarectools.RecordOptions.ACTUAL_POSITION_2,\n                datarectools.RecordOptions.COMMANDED_POSITION_1)\ndrec.sources = gcs.axes[0]\ndrec.trigsources = datarectools.TriggerSources.POSITION_CHANGING_COMMAND_1\ndrec.arm()\n\n\n\n\nThe following sample will configure two recordings of two axes.\n\n\ndrec.options = datarectools.RecordOptions.ACTUAL_POSITION_2\ndrec.sources = ['X', 'Y']\ndrec.trigsources = datarectools.TriggerSources.POSITION_CHANGING_COMMAND_1\ndrec.arm()\n\n\n\n\nThe following sample will configure four recordings of two analog inputs\nand two measurements regarding axis X.\n\n\ndrec.sources = [1, 2, 'X', 'X']\ndrec.options = [datarectools.RecordOptions.ANALOG_INPUT_81,\n                datarectools.RecordOptions.ANALOG_INPUT_81,\n                datarectools.RecordOptions.MOTOR_OUTPUT_73,\n                datarectools.RecordOptions.COMMANDED_POSITION_1]\ndrec.trigsources = datarectools.TriggerSources.POSITION_CHANGING_COMMAND_1\ndrec.arm()\n\n\n\n\nGet options from string\n\n\nIf you read the desired options for example from an INI file there\nare helper functions getrecopt() and gettrigsources() to translate a\ndescriptive string into the according option value. The following\nexample will set \ntrigsources\n to \nPOSITION_CHANGING_COMMAND_1\n.\n\n\nreadout = 'pos_chg_cmd'  # e.g. from an INI file\ndrec.trigsources = datarectools.gettrigsources(readout)\n\n\n\n\nThe first exact or abbreviated match of all parts of an option\n(i.e. in the example \"POSITION\", \"CHANGING\" and \"COMMAND\")\nis returned. The descriptive string is case insensitive.\nUse \"_\" as separator. The trailing number in the option name\nis not required for a match. Abbreviations must start with the\nfirst letter of the according part of an option.\n\n\nGet the data\n\n\nWait for the motion to finish\n\n\nAfter you started the triggering event (for example a motion) you\ncan wait until the motion has finished with the \"wait\" helper\nfunctions in \npipython.pitools\n.\n\n\ngcs.MVR(axis, 1.0)\npitools.waitontarget(gcs, axis)\n\n\n\n\nGet the data recorder data\n\n\nFinally you will read out the recorded data from the device with\nthe GCS command \nqDRR\n. This command returns immediately with the\n\nGCS header\n containing information about the data recorder data.\nThen it starts a background task that keeps on storing the data\nstill coming from the controller in an internal buffer. Check the\ncurrent state of this buffer with the \nbufstate\n property. It will\nturn \nTrue\n when the task has finshed. Prior to that it is a float\nvalue in the range 0..1 indicating the progress of the data\ntransfer. Hence end a loop with \nwhile bufstate is not True\n and\nnot with \nwhile not bufstate\n.\n\n\nheader = gcs.qDRR(rectables, offset, numvalues)\nwhile gcs.bufstate is not True:\n    print('read data {:.1f}%...'.format(gcs.bufstate * 100))\n    sleep(0.1)\n\n\n\n\nRemember that the task running in the background will lock the\ncommunication to the device. Hence your application indeed is\nable to continue after the \nqDRR\n command but when you try to\ncommunicate to the device during data readout this will result\nin a deadlock! To prevent this always check the\n\nGCSDevice.locked\n property.\n\n\nFor your convenience you can use Datarecorder.getdata() instead.\nIt will wait until the desired data has been recorded and will\nthen return the header and the data as two-dimensional list\nwhere the first index indicates the record table and the second\nindex indicates the value in this record table.\n\n\nheader, data = drec.getdata()\n\n\n\n\nProcess data\n\n\nThe sample below shows how to use the \nheader\n and the \ndata\n from\na recording of two tables to create a plot. (This requires matplotlib.)\n\n\n    timescale = [header['SAMPLE_TIME'] * i for i in range(len(data[0]))]\n    pyplot.plot(timescale, data[0], color='red')\n    pyplot.plot(timescale, data[1], color='blue')\n    pyplot.xlabel('time (s)')\n    pyplot.ylabel(', '.join((header['NAME0'], header['NAME1'])))\n    pyplot.title('Datarecorder data over time')\n    pyplot.grid(True)\n    pyplot.show()\n\n\n\n\nIf you are used to NumPy you can easily convert the datarecorder data\ninto a NumPy array.\n\n\nimport numpy as np\n...\nheader, data = drec.getdata()\nnpdata = np.array(data)\n\n\n\n\nAppendix\n\n\nWait for recording\n\n\nTo wait for the data recording to finish you can use \nwait()\n and \nread()\n instead\nof \ngetdata()\n\n\ndrec.arm()\ndrec.wait()\n# recording is now finished\nheader, data = drec.read()", 
            "title": "Datarecorder"
        }, 
        {
            "location": "/datarecorder/index.html#data-recorder", 
            "text": "A PI device has one or more record tables that can be filled with\nfloat values (i.e. numbers). The typical workflow is as following.   Set the record rate.  Configure the data to be recorded.  Configure the trigger event that starts the recorder.  Perform the action that should be recorded.  Wait until the action is finished.  Wait until the data has been recorded.  Start reading out the data from the controller.  Wait until all data has been read out from the device.  Process the data.   Please find an according sample in  samples/datarecorder.py .", 
            "title": "Data recorder"
        }, 
        {
            "location": "/datarecorder/index.html#prepare-the-data-recorder", 
            "text": "", 
            "title": "Prepare the data recorder"
        }, 
        {
            "location": "/datarecorder/index.html#set-the-record-rate", 
            "text": "With the GCS command  RTR  you can set the record rate in multiples of\nthe device specific servo loop time. Hence the higher the RTR rate is the\nslower the data is recorded. For your convenience the Datarecorder() class\ntakes a record rate in Hertz and seconds, too.  from pipython import GCSDevice\nfrom pipython import datarectools, pitools\ngcs = GCSDevice()\ngcs.InterfaceSetupDlg()\n...\ndrec = datarectools.Datarecorder(gcs)\n# drec.samplerate = 1  # servo cycles\n# drec.sampletime = 1E-5  # seconds\ndrec.samplefrequ = 1000  # Hertz\nprint('data recorder rate: {:d} servo cycles'.format(drec.samplerate))\nprint('data recorder rate: {:.g} seconds'.format(drec.sampletime))\nprint('data recorder rate: {:.2f} Hertz'.format(drec.samplefrequ))", 
            "title": "Set the record rate"
        }, 
        {
            "location": "/datarecorder/index.html#set-the-record-time", 
            "text": "By default the entire data recorder memory is used to record the data.\nYou can reduce the number of points with the  numvalues  property. Or\nyou set the time to record in seconds with  rectime  which adjusts numvalues  accordingly. The  rectimemax  property will use the entire\ndata recorder memory and will adjust the  samplerate  accordingly.  Further on  gcs  is referred as instance of pipython.GCSDevice and  drec \nis referred as instance of pipython.datarectools.Datarecorder.", 
            "title": "Set the record time"
        }, 
        {
            "location": "/datarecorder/index.html#configure-data-recorder", 
            "text": "With the GCS command  DRC  you can configure which measurement\n(the  record option ) of which  record source  (e.g. an axis\nor channel) is recorded in a specified  record table .  There is an enumeration  pipython.datarectools.RecordOptions  available.  The function  Datarecorder.record()  takes one\nor more  axes , one or more  record options  and one or more trigger options . If you call it with a single axis and several record options  it will take the given axis for all recordings.\nAnd vice versa it will take a single  record option  for several\ngiven  axes . When you omit the  axes  argument all connected\naxes are taken. If you omit the  record option  then RecordOptions.ACTUAL_POSITION_2  is taken.\nIt will return a list of record table IDs where the desired data\nwill be stored. See the example code below.", 
            "title": "Configure data recorder"
        }, 
        {
            "location": "/datarecorder/index.html#configure-the-trigger-event", 
            "text": "With the GCS command  DRT  you can configure when the recording will\nstart, e.g.  immediately  or with the  next command that changes a\nposition , i.e. that makes a motion.  There is an enumeration  pipython.datarectools.TriggerSources  available.  If you call the function Datarecorder.record() with\na single value as  trigger option  it will use the  DRT  command\nwith the record table \"0\". If it is called with a list as argument it\nwill use  DRT  with the according record table IDs. See the controller\nuser manual which is the appropriate way for your device.\nIf you omit the  trigger options  argument then TriggerSources.NEXT_COMMAND_WITH_RESET_2  is taken.\nIf  TriggerSources.NEXT_COMMAND_WITH_RESET_2  is used then the error\ncheck will be disabled automatically.  The following sample will configure two recordings of one axis\ntriggered by a position changing command and arm the data recorder.  drec.options = (datarectools.RecordOptions.ACTUAL_POSITION_2,\n                datarectools.RecordOptions.COMMANDED_POSITION_1)\ndrec.sources = gcs.axes[0]\ndrec.trigsources = datarectools.TriggerSources.POSITION_CHANGING_COMMAND_1\ndrec.arm()  The following sample will configure two recordings of two axes.  drec.options = datarectools.RecordOptions.ACTUAL_POSITION_2\ndrec.sources = ['X', 'Y']\ndrec.trigsources = datarectools.TriggerSources.POSITION_CHANGING_COMMAND_1\ndrec.arm()  The following sample will configure four recordings of two analog inputs\nand two measurements regarding axis X.  drec.sources = [1, 2, 'X', 'X']\ndrec.options = [datarectools.RecordOptions.ANALOG_INPUT_81,\n                datarectools.RecordOptions.ANALOG_INPUT_81,\n                datarectools.RecordOptions.MOTOR_OUTPUT_73,\n                datarectools.RecordOptions.COMMANDED_POSITION_1]\ndrec.trigsources = datarectools.TriggerSources.POSITION_CHANGING_COMMAND_1\ndrec.arm()", 
            "title": "Configure the trigger event"
        }, 
        {
            "location": "/datarecorder/index.html#get-options-from-string", 
            "text": "If you read the desired options for example from an INI file there\nare helper functions getrecopt() and gettrigsources() to translate a\ndescriptive string into the according option value. The following\nexample will set  trigsources  to  POSITION_CHANGING_COMMAND_1 .  readout = 'pos_chg_cmd'  # e.g. from an INI file\ndrec.trigsources = datarectools.gettrigsources(readout)  The first exact or abbreviated match of all parts of an option\n(i.e. in the example \"POSITION\", \"CHANGING\" and \"COMMAND\")\nis returned. The descriptive string is case insensitive.\nUse \"_\" as separator. The trailing number in the option name\nis not required for a match. Abbreviations must start with the\nfirst letter of the according part of an option.", 
            "title": "Get options from string"
        }, 
        {
            "location": "/datarecorder/index.html#get-the-data", 
            "text": "", 
            "title": "Get the data"
        }, 
        {
            "location": "/datarecorder/index.html#wait-for-the-motion-to-finish", 
            "text": "After you started the triggering event (for example a motion) you\ncan wait until the motion has finished with the \"wait\" helper\nfunctions in  pipython.pitools .  gcs.MVR(axis, 1.0)\npitools.waitontarget(gcs, axis)", 
            "title": "Wait for the motion to finish"
        }, 
        {
            "location": "/datarecorder/index.html#get-the-data-recorder-data", 
            "text": "Finally you will read out the recorded data from the device with\nthe GCS command  qDRR . This command returns immediately with the GCS header  containing information about the data recorder data.\nThen it starts a background task that keeps on storing the data\nstill coming from the controller in an internal buffer. Check the\ncurrent state of this buffer with the  bufstate  property. It will\nturn  True  when the task has finshed. Prior to that it is a float\nvalue in the range 0..1 indicating the progress of the data\ntransfer. Hence end a loop with  while bufstate is not True  and\nnot with  while not bufstate .  header = gcs.qDRR(rectables, offset, numvalues)\nwhile gcs.bufstate is not True:\n    print('read data {:.1f}%...'.format(gcs.bufstate * 100))\n    sleep(0.1)  Remember that the task running in the background will lock the\ncommunication to the device. Hence your application indeed is\nable to continue after the  qDRR  command but when you try to\ncommunicate to the device during data readout this will result\nin a deadlock! To prevent this always check the GCSDevice.locked  property.  For your convenience you can use Datarecorder.getdata() instead.\nIt will wait until the desired data has been recorded and will\nthen return the header and the data as two-dimensional list\nwhere the first index indicates the record table and the second\nindex indicates the value in this record table.  header, data = drec.getdata()", 
            "title": "Get the data recorder data"
        }, 
        {
            "location": "/datarecorder/index.html#process-data", 
            "text": "The sample below shows how to use the  header  and the  data  from\na recording of two tables to create a plot. (This requires matplotlib.)      timescale = [header['SAMPLE_TIME'] * i for i in range(len(data[0]))]\n    pyplot.plot(timescale, data[0], color='red')\n    pyplot.plot(timescale, data[1], color='blue')\n    pyplot.xlabel('time (s)')\n    pyplot.ylabel(', '.join((header['NAME0'], header['NAME1'])))\n    pyplot.title('Datarecorder data over time')\n    pyplot.grid(True)\n    pyplot.show()  If you are used to NumPy you can easily convert the datarecorder data\ninto a NumPy array.  import numpy as np\n...\nheader, data = drec.getdata()\nnpdata = np.array(data)", 
            "title": "Process data"
        }, 
        {
            "location": "/datarecorder/index.html#appendix", 
            "text": "", 
            "title": "Appendix"
        }, 
        {
            "location": "/datarecorder/index.html#wait-for-recording", 
            "text": "To wait for the data recording to finish you can use  wait()  and  read()  instead\nof  getdata()  drec.arm()\ndrec.wait()\n# recording is now finished\nheader, data = drec.read()", 
            "title": "Wait for recording"
        }, 
        {
            "location": "/history/index.html", 
            "text": "Feature Version History\n\n\nPIPython 1.5.0\n\n\n\n\nadd GCSCommands.POL()\n\n\nadd GCSCommands.STD()\n\n\nadd GCSCommands.RTD()\n\n\nadd GCSCommands.qRTD()\n\n\nadd GCSCommands.qLST()\n\n\nadd GCSCommands.DTL()\n\n\n\n\nPIPython 1.4.0\n\n\n\n\nfix string decoding in GCSDll()\n\n\nadd pitools.getservo()\n\n\npitools.waitonreferencing() does not call waitontarget()\n\n\nin pitools call waitonready() with the \"polldelay\" argument\n\n\nfix signature of GCSCommands.qTWS()\n\n\nGCSCommands.CCL() will reset the list of supported GCS commands\n\n\ninterfaces.pisocket.PISocket() uses socket.TCP_NODELAY\n\n\nadd \"ATZ\" as \"referencing command\" to pitools.DeviceStartup()\n\n\nadd GCSMessages.logfile property\n\n\nrename license.md to eula.md\n\n\nadd datarectools.get_hdr_options()\n\n\nadd Datarecorder.recopts property\n\n\nadd Datarecorder.trigopts property\n\n\nall timeout default values are set to 300 seconds\n\n\n\n\nPIPython 1.3.9\n\n\n\n\nadd pitools.waitonmacro()\n\n\ncatch GCS error 2 (unknown command) after EAX during startup\n\n\nGCS commands arguments can be sets, too\n\n\nDDL(tables, offsets, values) -\n DDL(table, offsets, values)\n\n\nadd GCSDevice.isavailable\n\n\nconvert parameter values according to types in qHPA answer\n\n\nfix signature of GCSCommands.qJLT()\n\n\n\n\nPIPython 1.3.8\n\n\n\n\nadd interfaces.piusb\n\n\nadd pitools.readgcsarray()\n\n\nadd pitools.waitonwavegen()\n\n\nadd pitools.moveandwait()\n\n\nadd piparams.applyconfig()\n\n\npitools.startup() defines and references stages only if necessary\n\n\nadd GCSCommands.allaxes\n\n\nadd GCSDevice.hasref()\n\n\nadd GCSDevice.haslim()\n\n\nadd GCSDevice.canfrf()\n\n\nadd GCSDevice.canfnl()\n\n\nadd GCSDevice.canfpl()\n\n\nadd pitools.waitonphase()\n\n\nadd pitools.setservo()\n\n\ncontroller specific startup sequence\n\n\n\n\nPIPython 1.3.7\n\n\n\n\nadd pitools.movetomiddle()\n\n\nadd pipython.fastaligntools\n\n\nPI_GCS2_DLL is used by default\n\n\nadd pitools.savegcsarray()\n\n\nadd pitools.itemstostr()\n\n\n\n\nPIPython 1.3.6\n\n\n\n\nadd controller C-886, E-872\n\n\nGCSDevice supports external Gateway\n\n\n\n\nPIPython 1.3.5\n\n\n\n\nadd DLL functions for PIStages3\n\n\n\"wait on\" functions support polldelay times\n\n\nfix GCSCommands.SGA()\n\n\nfix GCSCommands.qSPA()\n\n\nfix GCSCommands.qSEP()\n\n\nadd optional argument \"noraise\" for StopAll(), HLT(), STP()\n\n\nadd pitools.waitonfastalign()\n\n\nadd pitools.waitonautozero()\n\n\nadd GCS Error codes\n\n\n\n\nPIPython 1.3.4\n\n\n\n\nadd pipython.interfaces.piserial\n\n\n\"wait on\" functions support predelay and postdelay times\n\n\nadd GCSCommands.TSP()\n\n\nsetup writes key for PIUpdateFinder always into 32 bit part of registry\n\n\nchange formatting of numbers in GCS strings\n\n\nGCSDll supports \"K\" devices\n\n\nGCSMessages.bufstate will not write to log\n\n\nrename ReadGCSData() -\n read_gcsdata()\n\n\nadd controller C-663.12\n\n\nadd parameters for E-873.3QTU, C-663.10C885\n\n\nadd GCS Error codes\n\n\nbugfixing\n\n\n\n\nPIPython 1.3.3\n\n\n\n\nadd GCSCommands.SGP()\n\n\nadd GCSCommands.qSGP()\n\n\nadd GCSCommands.WAV_SIN()\n\n\nadd GCSCommands.WAV_POL()\n\n\nadd GCSCommands.WAV_TAN()\n\n\nadd GCSCommands.WAV_SWEEP()\n\n\nadd GCSCommands.checkerror()\n\n\nadd GCSCommands.DEL()\n\n\nadd new controllers\n\n\nadd controller parameters\n\n\nfix for handling unicode in Python 3\n\n\nbugfixing of some GCS commands\n\n\n\n\nPIPython 1.3.2\n\n\n\n\nadd GCSCommands.FSF()\n\n\nadd GCSCommands.qFSF()\n\n\nadd GCSCommands.qFSR()\n\n\nadd pitools.getaxeslist()\n\n\nadd pitools.ontarget()\n\n\nadd pitools.waitonwalk()\n\n\nadd pitools.waitonoma()\n\n\nadd pitools.waitontrajectory()\n\n\nfix DLL function prefix", 
            "title": "History"
        }, 
        {
            "location": "/history/index.html#feature-version-history", 
            "text": "", 
            "title": "Feature Version History"
        }, 
        {
            "location": "/history/index.html#pipython-150", 
            "text": "add GCSCommands.POL()  add GCSCommands.STD()  add GCSCommands.RTD()  add GCSCommands.qRTD()  add GCSCommands.qLST()  add GCSCommands.DTL()", 
            "title": "PIPython 1.5.0"
        }, 
        {
            "location": "/history/index.html#pipython-140", 
            "text": "fix string decoding in GCSDll()  add pitools.getservo()  pitools.waitonreferencing() does not call waitontarget()  in pitools call waitonready() with the \"polldelay\" argument  fix signature of GCSCommands.qTWS()  GCSCommands.CCL() will reset the list of supported GCS commands  interfaces.pisocket.PISocket() uses socket.TCP_NODELAY  add \"ATZ\" as \"referencing command\" to pitools.DeviceStartup()  add GCSMessages.logfile property  rename license.md to eula.md  add datarectools.get_hdr_options()  add Datarecorder.recopts property  add Datarecorder.trigopts property  all timeout default values are set to 300 seconds", 
            "title": "PIPython 1.4.0"
        }, 
        {
            "location": "/history/index.html#pipython-139", 
            "text": "add pitools.waitonmacro()  catch GCS error 2 (unknown command) after EAX during startup  GCS commands arguments can be sets, too  DDL(tables, offsets, values) -  DDL(table, offsets, values)  add GCSDevice.isavailable  convert parameter values according to types in qHPA answer  fix signature of GCSCommands.qJLT()", 
            "title": "PIPython 1.3.9"
        }, 
        {
            "location": "/history/index.html#pipython-138", 
            "text": "add interfaces.piusb  add pitools.readgcsarray()  add pitools.waitonwavegen()  add pitools.moveandwait()  add piparams.applyconfig()  pitools.startup() defines and references stages only if necessary  add GCSCommands.allaxes  add GCSDevice.hasref()  add GCSDevice.haslim()  add GCSDevice.canfrf()  add GCSDevice.canfnl()  add GCSDevice.canfpl()  add pitools.waitonphase()  add pitools.setservo()  controller specific startup sequence", 
            "title": "PIPython 1.3.8"
        }, 
        {
            "location": "/history/index.html#pipython-137", 
            "text": "add pitools.movetomiddle()  add pipython.fastaligntools  PI_GCS2_DLL is used by default  add pitools.savegcsarray()  add pitools.itemstostr()", 
            "title": "PIPython 1.3.7"
        }, 
        {
            "location": "/history/index.html#pipython-136", 
            "text": "add controller C-886, E-872  GCSDevice supports external Gateway", 
            "title": "PIPython 1.3.6"
        }, 
        {
            "location": "/history/index.html#pipython-135", 
            "text": "add DLL functions for PIStages3  \"wait on\" functions support polldelay times  fix GCSCommands.SGA()  fix GCSCommands.qSPA()  fix GCSCommands.qSEP()  add optional argument \"noraise\" for StopAll(), HLT(), STP()  add pitools.waitonfastalign()  add pitools.waitonautozero()  add GCS Error codes", 
            "title": "PIPython 1.3.5"
        }, 
        {
            "location": "/history/index.html#pipython-134", 
            "text": "add pipython.interfaces.piserial  \"wait on\" functions support predelay and postdelay times  add GCSCommands.TSP()  setup writes key for PIUpdateFinder always into 32 bit part of registry  change formatting of numbers in GCS strings  GCSDll supports \"K\" devices  GCSMessages.bufstate will not write to log  rename ReadGCSData() -  read_gcsdata()  add controller C-663.12  add parameters for E-873.3QTU, C-663.10C885  add GCS Error codes  bugfixing", 
            "title": "PIPython 1.3.4"
        }, 
        {
            "location": "/history/index.html#pipython-133", 
            "text": "add GCSCommands.SGP()  add GCSCommands.qSGP()  add GCSCommands.WAV_SIN()  add GCSCommands.WAV_POL()  add GCSCommands.WAV_TAN()  add GCSCommands.WAV_SWEEP()  add GCSCommands.checkerror()  add GCSCommands.DEL()  add new controllers  add controller parameters  fix for handling unicode in Python 3  bugfixing of some GCS commands", 
            "title": "PIPython 1.3.3"
        }, 
        {
            "location": "/history/index.html#pipython-132", 
            "text": "add GCSCommands.FSF()  add GCSCommands.qFSF()  add GCSCommands.qFSR()  add pitools.getaxeslist()  add pitools.ontarget()  add pitools.waitonwalk()  add pitools.waitonoma()  add pitools.waitontrajectory()  fix DLL function prefix", 
            "title": "PIPython 1.3.2"
        }, 
        {
            "location": "/structure/index.html", 
            "text": "Package overview\n\n\nDiagram of PIPython\n\n\nPIPython is made of three layers. The commands layer provides GCS commands, the\nmessage layer handles GCS messages and the communication layer connects the device.\n\n\nThe following diagram only shows the public items of the classes.\n\n\n\n\nLayers\n\n\nCommands layer\n\n\nModules: pipython.gcscommands, pipython.gcsdevice\n\n\nA \nGCSCommands\n instance provides functions for the GCS commands and properties of\nthe connected device and stages. For each GCS function there is an according \"Has\"\nfunction which returns True if the connected device supports this command.\n\n\nA \nGCSDevice\n instance inherits from \nGCSCommands\n and provides access to some\nproperties and methods of the \nGCSDll\n, too. It needs a \nGCSDll\n instance and\ndoes not work with \nPISocket\n. \nGCSDevice\n is a context manager that will\nunload the \nGCSDll\n.\n\n\nMessage layer\n\n\nModules: pipython.gcsmessages\n\n\nA \nGCSMessage\n instance connects a communication gateway and a \nGCSCommands\n instance.\n\n\nIt delivers the command string from a GCS command to the gateway. A proper line \nending is made. For query commands it returns the answer from the gateway when it \nhas received a GCS conforming end of message signature. Then optionally the error \nstate is queried from the gateway. A background thread to read out big GCS data \nis provided.\n\n\nComunication layer\n\n\nModules: pipython.interfaces.pigateway, pipython.interfaces.gcsdll,\npipython.interfaces.pisocket\n\n\nThis is the gateway to a device. A connection to the device is established\nautomatically, by provided commands or the device is already connected. \n\n\nUsually you will use an \nGCSDll\n instance which will be able to connect a GCS device\nover RS-232, USB, TCP/IP, GPIB, PCI and daisy chain. On platforms where no GCS DLL\nis available you can use the \nPISocket\n over TCP/IP. The \nGCSCommandsWrapper\n is for\ninternal use only.\n\n\nThe socket module is called \npisocket\n to not interfere with the builtin module. But\nit is a plain python socket without any GCS implementations.\n\n\nInherit from the interface (in terms of \"base class\") \nPIGateway\n when implementing\nother gateways.", 
            "title": "Structure"
        }, 
        {
            "location": "/structure/index.html#package-overview", 
            "text": "", 
            "title": "Package overview"
        }, 
        {
            "location": "/structure/index.html#diagram-of-pipython", 
            "text": "PIPython is made of three layers. The commands layer provides GCS commands, the\nmessage layer handles GCS messages and the communication layer connects the device.  The following diagram only shows the public items of the classes.", 
            "title": "Diagram of PIPython"
        }, 
        {
            "location": "/structure/index.html#layers", 
            "text": "", 
            "title": "Layers"
        }, 
        {
            "location": "/structure/index.html#commands-layer", 
            "text": "Modules: pipython.gcscommands, pipython.gcsdevice  A  GCSCommands  instance provides functions for the GCS commands and properties of\nthe connected device and stages. For each GCS function there is an according \"Has\"\nfunction which returns True if the connected device supports this command.  A  GCSDevice  instance inherits from  GCSCommands  and provides access to some\nproperties and methods of the  GCSDll , too. It needs a  GCSDll  instance and\ndoes not work with  PISocket .  GCSDevice  is a context manager that will\nunload the  GCSDll .", 
            "title": "Commands layer"
        }, 
        {
            "location": "/structure/index.html#message-layer", 
            "text": "Modules: pipython.gcsmessages  A  GCSMessage  instance connects a communication gateway and a  GCSCommands  instance.  It delivers the command string from a GCS command to the gateway. A proper line \nending is made. For query commands it returns the answer from the gateway when it \nhas received a GCS conforming end of message signature. Then optionally the error \nstate is queried from the gateway. A background thread to read out big GCS data \nis provided.", 
            "title": "Message layer"
        }, 
        {
            "location": "/structure/index.html#comunication-layer", 
            "text": "Modules: pipython.interfaces.pigateway, pipython.interfaces.gcsdll,\npipython.interfaces.pisocket  This is the gateway to a device. A connection to the device is established\nautomatically, by provided commands or the device is already connected.   Usually you will use an  GCSDll  instance which will be able to connect a GCS device\nover RS-232, USB, TCP/IP, GPIB, PCI and daisy chain. On platforms where no GCS DLL\nis available you can use the  PISocket  over TCP/IP. The  GCSCommandsWrapper  is for\ninternal use only.  The socket module is called  pisocket  to not interfere with the builtin module. But\nit is a plain python socket without any GCS implementations.  Inherit from the interface (in terms of \"base class\")  PIGateway  when implementing\nother gateways.", 
            "title": "Comunication layer"
        }, 
        {
            "location": "/eula/index.html", 
            "text": "License Agreement\n\n\nGeneral Software License Agreement of Physik Instrumente (PI) GmbH \n Co. KG\n\n\nIssued: April 16, 2018\n\n\nPreamble\n\n\nPhysik Instrumente (PI) GmbH \n Co. KG (hereinafter referred to as \"PI\") is a manufacturer and provider of micro- and nanopositioning technology and motion control systems, devices and apparatuses including their respective firmware (hereinafter jointly referred to as \"the PI Hardware\"), which can either be used independently or as an integral part of other third-party hardware systems. For the purpose of operating the PI Hardware, PI provides its customers, which either purchase the PI Hardware directly from PI for their own use or which integrate the PI Hardware into third-party hardware systems for distribution to their clients (hereinafter jointly referred to as \"the Customer\") with software products or tools (hereinafter jointly referred to as \"the Software\").\n\n\nThe following general terms and conditions (hereinafter referred to as \"Terms and Conditions\") shall apply to any Software provided by PI to the Customer, unless expressly agreed or stated otherwise herein, and may be supplemented by specific terms and conditions for individual software components.\n\n\nI. Scope\n\n\n(1) These Terms and Conditions shall apply to the supply of Software for its use together with PI Hardware and the granting of rights of use to the Customer, as described below.\n\n\n(2) The Software is supplied by PI to the Customer either in machine-readable form or with regard to certain software components in machine-readable form together with its source code and is subject to the following Terms and Conditions, unless PI and the Customer have agreed otherwise in writing.\n\n\n(3) These Terms and Conditions shall not apply to the PI Hardware.\n\n\n(4) PI does not owe any installation and configuration services under these Terms and Conditions.\n\n\n(5) The Software is not designed for use in medical devices (Medizinprodukt) according to section 3 of the German Act on Medical Devices (MPG).\n\n\n(6) References to the application of statutory provisions only serve clarification purposes. Therefore, the statutory provisions apply even without such clarification, unless modified directly by these Terms and Conditions.\n\n\nII. Rights of Use\n\n\n(1) Unless stated otherwise herein, PI grants to the Customer a non-exclusive territorially unrestricted right to use the Software for an unlimited period of time on the basis of the following provisions.\n\n\n(2) The following restrictions apply, if not explicitly agreed otherwise:\n\n\n(i) The Customer shall be entitled to use the Software insofar as this is required for the contractually agreed or contractually intended use of the Software and in accordance with these Terms and Conditions, including the right to install the Software onto a hard disk drive and/or to load it into the random access memory (RAM). If not specified otherwise, the Customer is entitled to use the Software within its company on several devices or on several workstations simultaneously and to duplicate the Software for that purpose. In the event that the use of the Software depends on a prior activation and is therefore limited to a certain license key (to be individually purchased by the Customer from PI), the use of the affected Software shall however be restricted to the respective device for which the Software has been activated by the Customer. The Software shall in any case be used by the Customer exclusively for and in relation with the operation of PI Hardware. The Customer shall insofar however be entitled to use the Software together with third-party software or to combine the Software with third-party software products, as far as necessary to operate its or any third-party systems that do include the PI Hardware.\n\n\n(ii) The Customer shall furthermore be entitled to generate application-specific, loadable and executable software products with the Software and to transfer such software products to third parties only for use for and in relation with the operation of PI Hardware. Such third party shall not be granted any rights of use beyond the rights of use granted to Customer under these Terms and Conditions. Moreover, the Customer shall contractually ensure that such third party shall be bound by the contractual obligations under these Terms and Conditions with regard to the software products.\n\n\n(iii) The Customer shall be entitled to transfer the right of use granted hereunder to a third party, provided that such third party agrees to the continued validity of the rights of use for and in relation with the PI Hardware and that the Customer deletes any remaining copies of the Software without undue delay. Such a third party shall not be granted any rights of use beyond the rights of use granted to the Customer under these Terms and Conditions. Moreover, the Customer shall contractually ensure that such third party uses the Software in accordance with these Terms and Conditions and in particular solely for the purpose of operating the PI Hardware. Subparagraph (xii) shall remain unaffected.\n\n\n(iv) The subleasing of the Software for commercial purposes is prohibited.\n\n\n(v) The Customer shall not grant any sublicenses of the Software, unless stipulated otherwise in these Terms and Conditions.\n\n\n(vi) The Customer shall not be entitled to modify, extend, reverse engineer, decompile, reverse assemble or disassemble Software delivered in machine-readable form (object code) unless it is necessary for the purpose of using the Software in accordance with its contractually agreed or contractually intended purpose, including the purpose of removing defects, or unless it is specifically permitted by law, particularly according to section 69a et sqq. of the German Copyright Act (UrhG), in any case only if PI does not provide the Customer with the required information or does not remove the defect within a reasonable period of time after having been requested to do so via an email sent by the Customer to support-software@pi.ws.\n\n\n(vii) If the Software or parts thereof are provided together with its source code, the Customer shall be entitled to modify the Software on the basis of the source code and to use the modified source code solely for the purpose of operating the PI Hardware and/or third-party systems that include the PI Hardware in accordance with these Terms and Conditions; provided, however, that the Customer shall always include in any such modification a brief summary of the changes made to the source code and the date of the modification. Subject to clause IV, PI shall not be held responsible for any claims resulting from such modification of the source code.\n\n\n(viii) Copyright notes, serial numbers as well as further characteristics for identification shall not be removed from the Software and copies thereof.\n\n\n(ix) PI may provide the Customer with Software which includes or may be used together with third-party software (including freeware and open source software components). PI informs the Customer about the third-party software used and provides the Customer with the corresponding license terms within the Third Party Software Note (http://www.physikinstrumente.com/download/TPSWNote_PhysikInstrumenteGmbH_Co_KG.pdf) to the extent requested by the respective licensor. With regard to third-party software listed in the Third Party Software Note, the respective license terms, which the third-party software is subject to, shall apply. In case of a breach of the third-party license terms, the respective licensor may also be entitled to make subsequent claims and rights in its own name.\n\n\n(x) If PI provides the Customer with amendments (patches, bug fixes, amendments to the manual etc.) or a new edition (updates, upgrades) of the Software within the scope of rectification or maintenance, which replace the originally provided Software, those are subject to these Terms and Conditions.\n\n\n(xi) In the event that PI provides the Customer with a test version of the Software, these Terms and Conditions apply accordingly, however, except that the Customer is granted with a right to use the Software, which is limited to the defined test period.\n\n\n(xii) A temporary use of the Software by a third person, who integrates the Software and PI Hardware with other products on behalf of the Customer, is considered as use by the Customer's company. Such third party shall use the Software only within the time period required for the integration or for providing support services to the Customer and shall be bound in accordance with the contractual obligations under these Terms and Conditions.\n\n\nIII. Rectification in case of defects\n\n\n(1) Definitions\n\n\n(i) The Software shall be deemed as defective in quality in the event that it does not show the contractually stipulated condition or it does not fit the contractually stipulated purpose.\n\n\n(ii) The Software is subject to proprietary rights (particularly copyrights) of PI and/or third parties. It constitutes a defect in title if required rights for the contract-based usage could not be legally granted to the Customer.\n\n\n(2) Statute of limitations\n\n\n(i) The statute of limitations for claims of defects is 12 months, calculated from the date of the delivery of the Software.\n\n\n(ii) This does not apply in the event of actions of PI or its representatives or vicarious agents (Erfuellungsgehilfen) in bad faith or in relation to guarantees granted.\n\n\n(3) Modifications to the Software by the Customer\n\n\nAs far as the Customer modifies the Software or has it modified by third parties, claims regarding defects in quality or title shall be invalidated, unless the Customer proofs that the defect was not caused by the modifications and also if the analysis and the removal of the defect is not affected by the modification.\n\n\n(4) Obligations to examine and notify defects\n\n\n(i) After delivery of the Software to the Customer, the Customer shall examine the Software for completeness and possible defects without undue delay, insofar as this is feasible in the orderly course of business, and notify PI immediately of any complaints. Otherwise, claims of the Customer as defined in the following clauses shall be excluded in relation to such defects in quality that would have been obvious within a properly conducted examination.\n\n\n(ii) Together with the notification of the defect, the Customer has to provide PI with comprehensible documentation thereof.\n\n\n(5) Supplementary performance (Nacherfuellung)\n\n\n(i) PI may rectify the defect by reworking the Software (Nachbesserung) or by supplying a replacement, as it chooses. The Customer may request within a reasonable time period a reworking or a supply of a replacement of the Software, if another type of supplementary performance is unreasonable.\n\n\n(ii) Alternatively, PI can rectify the defect by providing instructions electronically, by phone, in writing or by providing updates for download on its homepage to the Customer.\n\n\n(6) Measures in the event of alleged defects in title\n\n\n(i) Should a third party raise claims against the Customer based on the allegation that the Software or the designation of the Software infringes its intellectual property rights, the Customer will notify PI immediately thereof and entrust PI with the defense against the alleged claims as far as possible. The Customer will provide to PI any reasonable support in this regard.\n\n\n(ii) PI can remedy a defect in title by providing the Customer with a legally unchallengeable option to use either the Software or a legally unchallengeable modification of the Software, at its sole discretion.\n\n\nIf not stipulated otherwise, the regulations of this clause also remain applicable equivalently in relations to defects in title.\n\n\n(7) PI shall provide its services subject to the supplementary performance within a reasonable period.\n\n\n(8) Bad faith (Arglist), guarantees\n\n\nStatutory claims of the Customer remain unaffected in case of actions of PI or its representatives or vicarious agents in bad faith or in relation to guarantees granted. The stipulations of clause IV shall remain unaffected by this clause III.\n\n\nIV. Limitation of Liability\n\n\nPI only assumes liability under the following conditions:\n\n\n(1) For damage caused by PI or any of its legal representatives, executive staff or vicarious agents through willful intent or gross negligence, PI is liable without restriction.\n\n\n(2) PI is not liable for any violation of insignificant contractual obligations by minor negligence. With regard to a violation of essential contractual obligations (i.e. obligations which the contractual partner can expect to be fulfilled and the fulfilment of which is required for the due execution of the contract) PI's liability for damage caused by minor negligence is limited to anticipated damage typical to contracts of this kind (vertragstypisch vorhersehbare Schaeden). The same applies to violations of obligations through minor negligence committed by legal representatives, executive staff or vicarious agents of PI.\n\n\n(3) No license fee is charged to the Customer by PI for the use of any open source or freeware software component / product. Regarding such components / products, the Customer hereby accepts the application of the corresponding license terms which are attached in the Third Party Software Note (http://www.physikinstrumente.com/download/TPSWNote_PhysikInstrumenteGmbH_Co_KG.pdf). To the extent that there is a conflict between these Terms and Conditions and the respective license terms, the license terms shall prevail over these Terms and Conditions with regard to the respective open source or freeware software component / product. However, PI's liability for willful intent and gross negligence remains unaffected.\n\n\n(4) Notwithstanding the foregoing, contributory negligence of the Client diminishes the amount of any claims for damages, especially if caused by insufficient cooperation, organizational errors, insufficient data protection or a breach of other contractual duties.\n\n\n(5) The Customer is responsible to back up his data regularly. In the event of a loss of data caused by PI, the liability of PI is limited to the costs of reproducing the lost data on the basis of the backups that the Customer was under the obligation to conduct and for costs for reproducing data that would have been also lost, even if the Customer had conducted regular backups.\n\n\n(6) The aforementioned limitation of liability does not apply in the event of fraudulent intent, injury to life, body and health, breach of warranty, and claims based on the German Product Liability Act (ProduktHaftG).\n\n\nV. Final Provisions\n\n\n(1) The place of performance for deliveries shall be the registered office (Sitz) of PI.\n\n\n(2) The district court of Karlsruhe (Landgericht Karlsruhe) shall have jurisdiction over all disputes arising from or in connection with these Terms and Conditions. PI shall, however, be entitled to assert claims at the registered seat of the Customer.\n\n\n(3) The laws of Germany shall apply. International purchase laws shall not apply. This shall, in particular, refer to the UN Convention (CISG) on the International Sale of Goods.\n\n\n(4) The invalidity or unenforceability of any provision of these Terms and Conditions shall not affect the validity and enforceability of the other provisions. Invalid or unenforceable provisions shall be deemed to be replaced by such valid and enforceable provisions that shall be suitable to implement the economic purpose of the deleted provision to the greatest extent possible. The same applies for omissions.", 
            "title": "EULA"
        }, 
        {
            "location": "/eula/index.html#license-agreement", 
            "text": "General Software License Agreement of Physik Instrumente (PI) GmbH   Co. KG  Issued: April 16, 2018", 
            "title": "License Agreement"
        }, 
        {
            "location": "/eula/index.html#preamble", 
            "text": "Physik Instrumente (PI) GmbH   Co. KG (hereinafter referred to as \"PI\") is a manufacturer and provider of micro- and nanopositioning technology and motion control systems, devices and apparatuses including their respective firmware (hereinafter jointly referred to as \"the PI Hardware\"), which can either be used independently or as an integral part of other third-party hardware systems. For the purpose of operating the PI Hardware, PI provides its customers, which either purchase the PI Hardware directly from PI for their own use or which integrate the PI Hardware into third-party hardware systems for distribution to their clients (hereinafter jointly referred to as \"the Customer\") with software products or tools (hereinafter jointly referred to as \"the Software\").  The following general terms and conditions (hereinafter referred to as \"Terms and Conditions\") shall apply to any Software provided by PI to the Customer, unless expressly agreed or stated otherwise herein, and may be supplemented by specific terms and conditions for individual software components.", 
            "title": "Preamble"
        }, 
        {
            "location": "/eula/index.html#i-scope", 
            "text": "(1) These Terms and Conditions shall apply to the supply of Software for its use together with PI Hardware and the granting of rights of use to the Customer, as described below.  (2) The Software is supplied by PI to the Customer either in machine-readable form or with regard to certain software components in machine-readable form together with its source code and is subject to the following Terms and Conditions, unless PI and the Customer have agreed otherwise in writing.  (3) These Terms and Conditions shall not apply to the PI Hardware.  (4) PI does not owe any installation and configuration services under these Terms and Conditions.  (5) The Software is not designed for use in medical devices (Medizinprodukt) according to section 3 of the German Act on Medical Devices (MPG).  (6) References to the application of statutory provisions only serve clarification purposes. Therefore, the statutory provisions apply even without such clarification, unless modified directly by these Terms and Conditions.", 
            "title": "I. Scope"
        }, 
        {
            "location": "/eula/index.html#ii-rights-of-use", 
            "text": "(1) Unless stated otherwise herein, PI grants to the Customer a non-exclusive territorially unrestricted right to use the Software for an unlimited period of time on the basis of the following provisions.  (2) The following restrictions apply, if not explicitly agreed otherwise:  (i) The Customer shall be entitled to use the Software insofar as this is required for the contractually agreed or contractually intended use of the Software and in accordance with these Terms and Conditions, including the right to install the Software onto a hard disk drive and/or to load it into the random access memory (RAM). If not specified otherwise, the Customer is entitled to use the Software within its company on several devices or on several workstations simultaneously and to duplicate the Software for that purpose. In the event that the use of the Software depends on a prior activation and is therefore limited to a certain license key (to be individually purchased by the Customer from PI), the use of the affected Software shall however be restricted to the respective device for which the Software has been activated by the Customer. The Software shall in any case be used by the Customer exclusively for and in relation with the operation of PI Hardware. The Customer shall insofar however be entitled to use the Software together with third-party software or to combine the Software with third-party software products, as far as necessary to operate its or any third-party systems that do include the PI Hardware.  (ii) The Customer shall furthermore be entitled to generate application-specific, loadable and executable software products with the Software and to transfer such software products to third parties only for use for and in relation with the operation of PI Hardware. Such third party shall not be granted any rights of use beyond the rights of use granted to Customer under these Terms and Conditions. Moreover, the Customer shall contractually ensure that such third party shall be bound by the contractual obligations under these Terms and Conditions with regard to the software products.  (iii) The Customer shall be entitled to transfer the right of use granted hereunder to a third party, provided that such third party agrees to the continued validity of the rights of use for and in relation with the PI Hardware and that the Customer deletes any remaining copies of the Software without undue delay. Such a third party shall not be granted any rights of use beyond the rights of use granted to the Customer under these Terms and Conditions. Moreover, the Customer shall contractually ensure that such third party uses the Software in accordance with these Terms and Conditions and in particular solely for the purpose of operating the PI Hardware. Subparagraph (xii) shall remain unaffected.  (iv) The subleasing of the Software for commercial purposes is prohibited.  (v) The Customer shall not grant any sublicenses of the Software, unless stipulated otherwise in these Terms and Conditions.  (vi) The Customer shall not be entitled to modify, extend, reverse engineer, decompile, reverse assemble or disassemble Software delivered in machine-readable form (object code) unless it is necessary for the purpose of using the Software in accordance with its contractually agreed or contractually intended purpose, including the purpose of removing defects, or unless it is specifically permitted by law, particularly according to section 69a et sqq. of the German Copyright Act (UrhG), in any case only if PI does not provide the Customer with the required information or does not remove the defect within a reasonable period of time after having been requested to do so via an email sent by the Customer to support-software@pi.ws.  (vii) If the Software or parts thereof are provided together with its source code, the Customer shall be entitled to modify the Software on the basis of the source code and to use the modified source code solely for the purpose of operating the PI Hardware and/or third-party systems that include the PI Hardware in accordance with these Terms and Conditions; provided, however, that the Customer shall always include in any such modification a brief summary of the changes made to the source code and the date of the modification. Subject to clause IV, PI shall not be held responsible for any claims resulting from such modification of the source code.  (viii) Copyright notes, serial numbers as well as further characteristics for identification shall not be removed from the Software and copies thereof.  (ix) PI may provide the Customer with Software which includes or may be used together with third-party software (including freeware and open source software components). PI informs the Customer about the third-party software used and provides the Customer with the corresponding license terms within the Third Party Software Note (http://www.physikinstrumente.com/download/TPSWNote_PhysikInstrumenteGmbH_Co_KG.pdf) to the extent requested by the respective licensor. With regard to third-party software listed in the Third Party Software Note, the respective license terms, which the third-party software is subject to, shall apply. In case of a breach of the third-party license terms, the respective licensor may also be entitled to make subsequent claims and rights in its own name.  (x) If PI provides the Customer with amendments (patches, bug fixes, amendments to the manual etc.) or a new edition (updates, upgrades) of the Software within the scope of rectification or maintenance, which replace the originally provided Software, those are subject to these Terms and Conditions.  (xi) In the event that PI provides the Customer with a test version of the Software, these Terms and Conditions apply accordingly, however, except that the Customer is granted with a right to use the Software, which is limited to the defined test period.  (xii) A temporary use of the Software by a third person, who integrates the Software and PI Hardware with other products on behalf of the Customer, is considered as use by the Customer's company. Such third party shall use the Software only within the time period required for the integration or for providing support services to the Customer and shall be bound in accordance with the contractual obligations under these Terms and Conditions.", 
            "title": "II. Rights of Use"
        }, 
        {
            "location": "/eula/index.html#iii-rectification-in-case-of-defects", 
            "text": "(1) Definitions  (i) The Software shall be deemed as defective in quality in the event that it does not show the contractually stipulated condition or it does not fit the contractually stipulated purpose.  (ii) The Software is subject to proprietary rights (particularly copyrights) of PI and/or third parties. It constitutes a defect in title if required rights for the contract-based usage could not be legally granted to the Customer.  (2) Statute of limitations  (i) The statute of limitations for claims of defects is 12 months, calculated from the date of the delivery of the Software.  (ii) This does not apply in the event of actions of PI or its representatives or vicarious agents (Erfuellungsgehilfen) in bad faith or in relation to guarantees granted.  (3) Modifications to the Software by the Customer  As far as the Customer modifies the Software or has it modified by third parties, claims regarding defects in quality or title shall be invalidated, unless the Customer proofs that the defect was not caused by the modifications and also if the analysis and the removal of the defect is not affected by the modification.  (4) Obligations to examine and notify defects  (i) After delivery of the Software to the Customer, the Customer shall examine the Software for completeness and possible defects without undue delay, insofar as this is feasible in the orderly course of business, and notify PI immediately of any complaints. Otherwise, claims of the Customer as defined in the following clauses shall be excluded in relation to such defects in quality that would have been obvious within a properly conducted examination.  (ii) Together with the notification of the defect, the Customer has to provide PI with comprehensible documentation thereof.  (5) Supplementary performance (Nacherfuellung)  (i) PI may rectify the defect by reworking the Software (Nachbesserung) or by supplying a replacement, as it chooses. The Customer may request within a reasonable time period a reworking or a supply of a replacement of the Software, if another type of supplementary performance is unreasonable.  (ii) Alternatively, PI can rectify the defect by providing instructions electronically, by phone, in writing or by providing updates for download on its homepage to the Customer.  (6) Measures in the event of alleged defects in title  (i) Should a third party raise claims against the Customer based on the allegation that the Software or the designation of the Software infringes its intellectual property rights, the Customer will notify PI immediately thereof and entrust PI with the defense against the alleged claims as far as possible. The Customer will provide to PI any reasonable support in this regard.  (ii) PI can remedy a defect in title by providing the Customer with a legally unchallengeable option to use either the Software or a legally unchallengeable modification of the Software, at its sole discretion.  If not stipulated otherwise, the regulations of this clause also remain applicable equivalently in relations to defects in title.  (7) PI shall provide its services subject to the supplementary performance within a reasonable period.  (8) Bad faith (Arglist), guarantees  Statutory claims of the Customer remain unaffected in case of actions of PI or its representatives or vicarious agents in bad faith or in relation to guarantees granted. The stipulations of clause IV shall remain unaffected by this clause III.", 
            "title": "III. Rectification in case of defects"
        }, 
        {
            "location": "/eula/index.html#iv-limitation-of-liability", 
            "text": "PI only assumes liability under the following conditions:  (1) For damage caused by PI or any of its legal representatives, executive staff or vicarious agents through willful intent or gross negligence, PI is liable without restriction.  (2) PI is not liable for any violation of insignificant contractual obligations by minor negligence. With regard to a violation of essential contractual obligations (i.e. obligations which the contractual partner can expect to be fulfilled and the fulfilment of which is required for the due execution of the contract) PI's liability for damage caused by minor negligence is limited to anticipated damage typical to contracts of this kind (vertragstypisch vorhersehbare Schaeden). The same applies to violations of obligations through minor negligence committed by legal representatives, executive staff or vicarious agents of PI.  (3) No license fee is charged to the Customer by PI for the use of any open source or freeware software component / product. Regarding such components / products, the Customer hereby accepts the application of the corresponding license terms which are attached in the Third Party Software Note (http://www.physikinstrumente.com/download/TPSWNote_PhysikInstrumenteGmbH_Co_KG.pdf). To the extent that there is a conflict between these Terms and Conditions and the respective license terms, the license terms shall prevail over these Terms and Conditions with regard to the respective open source or freeware software component / product. However, PI's liability for willful intent and gross negligence remains unaffected.  (4) Notwithstanding the foregoing, contributory negligence of the Client diminishes the amount of any claims for damages, especially if caused by insufficient cooperation, organizational errors, insufficient data protection or a breach of other contractual duties.  (5) The Customer is responsible to back up his data regularly. In the event of a loss of data caused by PI, the liability of PI is limited to the costs of reproducing the lost data on the basis of the backups that the Customer was under the obligation to conduct and for costs for reproducing data that would have been also lost, even if the Customer had conducted regular backups.  (6) The aforementioned limitation of liability does not apply in the event of fraudulent intent, injury to life, body and health, breach of warranty, and claims based on the German Product Liability Act (ProduktHaftG).", 
            "title": "IV. Limitation of Liability"
        }, 
        {
            "location": "/eula/index.html#v-final-provisions", 
            "text": "(1) The place of performance for deliveries shall be the registered office (Sitz) of PI.  (2) The district court of Karlsruhe (Landgericht Karlsruhe) shall have jurisdiction over all disputes arising from or in connection with these Terms and Conditions. PI shall, however, be entitled to assert claims at the registered seat of the Customer.  (3) The laws of Germany shall apply. International purchase laws shall not apply. This shall, in particular, refer to the UN Convention (CISG) on the International Sale of Goods.  (4) The invalidity or unenforceability of any provision of these Terms and Conditions shall not affect the validity and enforceability of the other provisions. Invalid or unenforceable provisions shall be deemed to be replaced by such valid and enforceable provisions that shall be suitable to implement the economic purpose of the deleted provision to the greatest extent possible. The same applies for omissions.", 
            "title": "V. Final Provisions"
        }
    ]
}