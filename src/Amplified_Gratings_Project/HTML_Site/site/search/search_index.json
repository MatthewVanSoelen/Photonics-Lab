{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Amplified Gratings Project Summary The Amplified Gratings Application provides a graphical interface which provides users control over a PI nano stage controller. Specifically this program allows users to select a unit and type in a distance, step size, exposure time, and serial port. From that information the application does conversions from milimeters, microns or nanometers and displays an estimation of how long an experiment will take with those parameters. Once the begin experiment button is pressed, if all feilds are filled the application moves the connected stage the total distance, at increments of the input step size. The stage will wait for the given exposure time at each increment. Additional features are an abort experiment button which will stop the stage, and a display of the start time of the experiment. Use Instructions Connect computer to Pi nano Stage controller via RS232 cable. Run the Start.py file. Fill in information into the text box. Press begin experiment button Press the abort button to stop the experiment or let the experiment finish. Logic Flow Run Start.py Creates a RunApp object, which creates a GUI and a thread which will be used in the future to run the experiment. A MyGUI object is created Variables that hold the values for the distance, step size, exposure time and button text are created. Tkinter frames 0, 1, and 2 are created and initialized with Labels, Entries(text boxes), OptionMenus(dropdowns), and a button for starting and stopping the experiment. The clock labels are set to display zero. Filling textboxes triggers the function update_time_estimation() via the tkinter trace() function. Trace checks if the text in the boxes change, if they do then the time is updated to reflect the input experiment parameters. If not all parameters are filled then the time will be set to zero. Begin the experiment Press the begin/abort button, calling the pressed_button() function in the RunApp class. Press Button: when the experiment is not running. calls the run() function The run() function tries to get information from the GUI textboxes and convert them to millimeters. The button text is changed to \"abort experiment\", the start time is set, begin_experiment is set to true, and the experiment thread is started. Experiment_thread starts by calling worker_thread which calls run_experiment() run_experiment() uses PIPython to connect to the PI nano stage controller E-873. The controller than connects to stage \"Q-545.240\" Then the stage moves to the minimum position. Finally the loop begins which checks if Begin_experiment is true, if it is then a movement of step_size is made. If the experiment finishes begin_experiment is set to false, button text is changed to \u201cBegin Experiment\u201d, and the time is updated to zero. Pressing Button: when the experiment is running Calls the function stop_experiment() begin_experiment is set to false, the button text is set to \u201cBegin Experiment\u201d, and the start time is set to zero. Before each incremental movement of the motor begin_experiment will be checked, if false then movement will stop. Future Work Implementing shutter control Implementing pulse laser control Implementing multi stage(axis) control","title":"Home"},{"location":"#amplified-gratings-project","text":"","title":"Amplified Gratings Project"},{"location":"#summary","text":"The Amplified Gratings Application provides a graphical interface which provides users control over a PI nano stage controller. Specifically this program allows users to select a unit and type in a distance, step size, exposure time, and serial port. From that information the application does conversions from milimeters, microns or nanometers and displays an estimation of how long an experiment will take with those parameters. Once the begin experiment button is pressed, if all feilds are filled the application moves the connected stage the total distance, at increments of the input step size. The stage will wait for the given exposure time at each increment. Additional features are an abort experiment button which will stop the stage, and a display of the start time of the experiment.","title":"Summary"},{"location":"#use-instructions","text":"Connect computer to Pi nano Stage controller via RS232 cable. Run the Start.py file. Fill in information into the text box. Press begin experiment button Press the abort button to stop the experiment or let the experiment finish.","title":"Use Instructions"},{"location":"#logic-flow","text":"Run Start.py Creates a RunApp object, which creates a GUI and a thread which will be used in the future to run the experiment. A MyGUI object is created Variables that hold the values for the distance, step size, exposure time and button text are created. Tkinter frames 0, 1, and 2 are created and initialized with Labels, Entries(text boxes), OptionMenus(dropdowns), and a button for starting and stopping the experiment. The clock labels are set to display zero. Filling textboxes triggers the function update_time_estimation() via the tkinter trace() function. Trace checks if the text in the boxes change, if they do then the time is updated to reflect the input experiment parameters. If not all parameters are filled then the time will be set to zero. Begin the experiment Press the begin/abort button, calling the pressed_button() function in the RunApp class. Press Button: when the experiment is not running. calls the run() function The run() function tries to get information from the GUI textboxes and convert them to millimeters. The button text is changed to \"abort experiment\", the start time is set, begin_experiment is set to true, and the experiment thread is started. Experiment_thread starts by calling worker_thread which calls run_experiment() run_experiment() uses PIPython to connect to the PI nano stage controller E-873. The controller than connects to stage \"Q-545.240\" Then the stage moves to the minimum position. Finally the loop begins which checks if Begin_experiment is true, if it is then a movement of step_size is made. If the experiment finishes begin_experiment is set to false, button text is changed to \u201cBegin Experiment\u201d, and the time is updated to zero. Pressing Button: when the experiment is running Calls the function stop_experiment() begin_experiment is set to false, the button text is set to \u201cBegin Experiment\u201d, and the start time is set to zero. Before each incremental movement of the motor begin_experiment will be checked, if false then movement will stop.","title":"Logic Flow"},{"location":"#future-work","text":"Implementing shutter control Implementing pulse laser control Implementing multi stage(axis) control","title":"Future Work"},{"location":"Diagrams/","text":"Amplfied Gratings Diagrams The following are diagrams relivant to the Amplified Gratings Project, including a class diagrams, and a collboration diagram that shows the logic flow of the application. Amplified Gratings Class Diagram PIPython Class Diagram Collaboration Diagram","title":"Diagrams"},{"location":"Diagrams/#amplfied-gratings-diagrams","text":"The following are diagrams relivant to the Amplified Gratings Project, including a class diagrams, and a collboration diagram that shows the logic flow of the application.","title":"Amplfied Gratings Diagrams"},{"location":"Diagrams/#amplified-gratings-class-diagram","text":"","title":"Amplified Gratings Class Diagram"},{"location":"Diagrams/#pipython-class-diagram","text":"","title":"PIPython Class Diagram"},{"location":"Diagrams/#collaboration-diagram","text":"","title":"Collaboration Diagram"},{"location":"PIController/","text":"Communicating with PI nano stage controller e-873 In order to communitcate to PI nano stage controller e-873 I used the PIPython package sent to me by PI. This Package contains python resouces for connecting to PI devices, and controlling them. This package provides commands that are supported by devices which support General Command Set (GCS). Being able to communitcate to the controller means programs can be developed to controller multiple stages or PIDevices at once. I will breifly go over the essetial information needed to move a stage, which includes the information used to produce the Amplified Gratings. Part 1 When learning to communicate with the stage controller, looking at the samples included in the package was very helpful. The first step to connect to the controller is to create a GCSDevice object using the context manager \"with\". A context manager essetially manages computer resouces propperly, and it is the recommended way to begin a connection with a PI device. We will create a GCSDevice object and pass it the controllername in our case the controller name is \"E-873\", and this object pudevice. CONTROLLERNAME = 'E-873' with GCSDevice(CONTROLLERNAME) as pidevice: Next we will used the built in GCSDevice function \"ConnectRS232()\". This function on a low level is written using a library named \"Serial\" which is better known as PySerial. At this point additional debugging information can be found such as the devices identification string, version, etc. All these commands and descriptions can be found in the gcscommands.py file in the PIPython Package. Now that the computer is connect and can communicate with the controller we need to call the startup() function which connects and initilizes the stage(s) to the controller. (This step is inside of the \"with\" statment, the indentation is important) CONTROLLERNAME = 'E-873' STAGES = ['Q-545.240'] REFMODES = ['FNL', 'FRF'] with GCSDevice(CONTROLLERNAME) as pidevice: pitools.startup(pidevice, stages=STAGES, refmodes=REFMODES) The stages are now connected and also have GCS commands. Some commands are query commands which do not require parameters and will return information for all stages, such as: rangemin = pidevice.qTMN() # array of miniums where the index is the axis(stage) number. rangemax = pidevice.qTMX() # array of maximums where the index is the axis(stage) number. curpos = pidevice.qPOS() # array of current positions where the index is the axis(stage) number. There are also setter commands for which you do have to specify the axis. pidevice.MOV(axis, target) # moves stage to target, where target is a float within the min to max range. pitools.waitontarget(pidevice, axes=axis) # stops program until stage is in the desire position (In our cause the min is -13mm and max is 13mm) Many more commands can be found in the gcscommands.py file. Part 2 Lets create the movement portion of the Amplified Grating application. This application consists of a GUI asks users to provide a total distance, step size, and exposure time. I am assuming these three varibles are properly provided to this program as floats. To begin we will make set up the connect to the controller, and then to the stages. CONTROLLERNAME = 'E-873' STAGES = ['Q-545.240'] REFMODES = ['FNL', 'FRF'] with GCSDevice(CONTROLLERNAME) as pidevice: pitools.startup(pidevice, stages=STAGES, refmodes=REFMODES) Then we will query the stage for its max, min, and current position. rangemin = pidevice.qTMN() rangemax = pidevice.qTMX() curpos = pidevice.qPOS() (We are assuming we only have one stage, but this can be scaled to multiple) The goal is to make incremental steps over a total distance and at each point wait for the given exposure time. Because we want the starting position of all experiments to be consistent, the first step is to move the stage to a standard position. I decided the minumum because it provides the most amount of space to use for the experiment. The move to the minimum position: CONTROLLERNAME = 'E-873' STAGES = ['Q-545.240'] REFMODES = ['FNL', 'FRF'] with GCSDevice(CONTROLLERNAME) as pidevice: pitools.startup(pidevice, stages=STAGES, refmodes=REFMODES) rangemin = pidevice.qTMN() rangemax = pidevice.qTMX() curpos = pidevice.qPOS() axis = \"1\" pidevice.MOV(axis, rangemin[axis]) pitools.waitontarget(pidevice, axes=axis) Next we creat a for loop which will incrmentally increase the target position until it reaches a displacment of total distance. For this we will use the numpy package which provides the function \"arange(start, end, increment)\" which creates a float range. for target in numpy.arange(rangemin[axis] + step_size, rangemin[axis] + total_distance + step_size, step_size): pidevice.MOV(axis, target) pitools.waitontarget(pidevice, axes=axis) time.sleep(exposure_time) position = pidevice.qPOS(axis)[axis] print('current position of axis {} is {:.4f}'.format(axis, position)) The standard time python library is used to make the program wait for the given exposure time using the sleep function. An add feature of this program is it will print the current position of the stage with 4 significant figures each time a position is reach so the user can follow along with the experiment. The Program all together: CONTROLLERNAME = 'E-873' STAGES = ['Q-545.240'] REFMODES = ['FNL', 'FRF'] with GCSDevice(CONTROLLERNAME) as pidevice: pitools.startup(pidevice, stages=STAGES, refmodes=REFMODES) rangemin = pidevice.qTMN() rangemax = pidevice.qTMX() curpos = pidevice.qPOS() axis = \"1\" pidevice.MOV(axis, rangemin[axis]) pitools.waitontarget(pidevice, axes=axis) for target in numpy.arange(rangemin[axis] + step_size, rangemin[axis] + total_distance + step_size, step_size): pidevice.MOV(axis, target) pitools.waitontarget(pidevice, axes=axis) time.sleep(exposure_time) position = pidevice.qPOS(axis)[axis] print('current position of axis {} is {:.4f}'.format(axis, position))","title":"PIController"},{"location":"PIController/#communicating-with-pi-nano-stage-controller-e-873","text":"In order to communitcate to PI nano stage controller e-873 I used the PIPython package sent to me by PI. This Package contains python resouces for connecting to PI devices, and controlling them. This package provides commands that are supported by devices which support General Command Set (GCS). Being able to communitcate to the controller means programs can be developed to controller multiple stages or PIDevices at once. I will breifly go over the essetial information needed to move a stage, which includes the information used to produce the Amplified Gratings.","title":"Communicating with PI nano stage controller e-873"},{"location":"PIController/#part-1","text":"When learning to communicate with the stage controller, looking at the samples included in the package was very helpful. The first step to connect to the controller is to create a GCSDevice object using the context manager \"with\". A context manager essetially manages computer resouces propperly, and it is the recommended way to begin a connection with a PI device. We will create a GCSDevice object and pass it the controllername in our case the controller name is \"E-873\", and this object pudevice. CONTROLLERNAME = 'E-873' with GCSDevice(CONTROLLERNAME) as pidevice: Next we will used the built in GCSDevice function \"ConnectRS232()\". This function on a low level is written using a library named \"Serial\" which is better known as PySerial. At this point additional debugging information can be found such as the devices identification string, version, etc. All these commands and descriptions can be found in the gcscommands.py file in the PIPython Package. Now that the computer is connect and can communicate with the controller we need to call the startup() function which connects and initilizes the stage(s) to the controller. (This step is inside of the \"with\" statment, the indentation is important) CONTROLLERNAME = 'E-873' STAGES = ['Q-545.240'] REFMODES = ['FNL', 'FRF'] with GCSDevice(CONTROLLERNAME) as pidevice: pitools.startup(pidevice, stages=STAGES, refmodes=REFMODES)","title":"Part 1"},{"location":"PIController/#the-stages-are-now-connected-and-also-have-gcs-commands","text":"Some commands are query commands which do not require parameters and will return information for all stages, such as: rangemin = pidevice.qTMN() # array of miniums where the index is the axis(stage) number. rangemax = pidevice.qTMX() # array of maximums where the index is the axis(stage) number. curpos = pidevice.qPOS() # array of current positions where the index is the axis(stage) number. There are also setter commands for which you do have to specify the axis. pidevice.MOV(axis, target) # moves stage to target, where target is a float within the min to max range. pitools.waitontarget(pidevice, axes=axis) # stops program until stage is in the desire position (In our cause the min is -13mm and max is 13mm) Many more commands can be found in the gcscommands.py file.","title":"The stages are now connected and also have GCS commands."},{"location":"PIController/#part-2","text":"Lets create the movement portion of the Amplified Grating application. This application consists of a GUI asks users to provide a total distance, step size, and exposure time. I am assuming these three varibles are properly provided to this program as floats. To begin we will make set up the connect to the controller, and then to the stages. CONTROLLERNAME = 'E-873' STAGES = ['Q-545.240'] REFMODES = ['FNL', 'FRF'] with GCSDevice(CONTROLLERNAME) as pidevice: pitools.startup(pidevice, stages=STAGES, refmodes=REFMODES) Then we will query the stage for its max, min, and current position. rangemin = pidevice.qTMN() rangemax = pidevice.qTMX() curpos = pidevice.qPOS() (We are assuming we only have one stage, but this can be scaled to multiple) The goal is to make incremental steps over a total distance and at each point wait for the given exposure time. Because we want the starting position of all experiments to be consistent, the first step is to move the stage to a standard position. I decided the minumum because it provides the most amount of space to use for the experiment. The move to the minimum position: CONTROLLERNAME = 'E-873' STAGES = ['Q-545.240'] REFMODES = ['FNL', 'FRF'] with GCSDevice(CONTROLLERNAME) as pidevice: pitools.startup(pidevice, stages=STAGES, refmodes=REFMODES) rangemin = pidevice.qTMN() rangemax = pidevice.qTMX() curpos = pidevice.qPOS() axis = \"1\" pidevice.MOV(axis, rangemin[axis]) pitools.waitontarget(pidevice, axes=axis) Next we creat a for loop which will incrmentally increase the target position until it reaches a displacment of total distance. For this we will use the numpy package which provides the function \"arange(start, end, increment)\" which creates a float range. for target in numpy.arange(rangemin[axis] + step_size, rangemin[axis] + total_distance + step_size, step_size): pidevice.MOV(axis, target) pitools.waitontarget(pidevice, axes=axis) time.sleep(exposure_time) position = pidevice.qPOS(axis)[axis] print('current position of axis {} is {:.4f}'.format(axis, position)) The standard time python library is used to make the program wait for the given exposure time using the sleep function. An add feature of this program is it will print the current position of the stage with 4 significant figures each time a position is reach so the user can follow along with the experiment. The Program all together: CONTROLLERNAME = 'E-873' STAGES = ['Q-545.240'] REFMODES = ['FNL', 'FRF'] with GCSDevice(CONTROLLERNAME) as pidevice: pitools.startup(pidevice, stages=STAGES, refmodes=REFMODES) rangemin = pidevice.qTMN() rangemax = pidevice.qTMX() curpos = pidevice.qPOS() axis = \"1\" pidevice.MOV(axis, rangemin[axis]) pitools.waitontarget(pidevice, axes=axis) for target in numpy.arange(rangemin[axis] + step_size, rangemin[axis] + total_distance + step_size, step_size): pidevice.MOV(axis, target) pitools.waitontarget(pidevice, axes=axis) time.sleep(exposure_time) position = pidevice.qPOS(axis)[axis] print('current position of axis {} is {:.4f}'.format(axis, position))","title":"Part 2"},{"location":"Tkinter/","text":"Creating a GUI using Tkinter Part 1 Tkinter is a python package that provides resources to create interactive GUIs (graphical user interfaces). There are many resources online which provide tutorials and documentation for Tkinter, the following will be a brief overview and tutorial of a simple Tkinter based GUI. Tkinter is a standard package included in python so no downloads are necessary. To begin we will import the package, which tells python we want to use the resources inside of the Tkinter Package. Once imported we will create a window with the title \u201cAmplified Gratings\u201d. from tkinter import * window = Tk() window.title(\"Amplified Gratings\") window.mainloop() Our result: Next we will add a tkinter widget to the window. Widgets consist of a range of items such as a Labels, Buttons, or text fields. label = Label(window, text=\"hello\") In order to display a widget in the window we have to tell the window where it should be. This can be done using .grid(), .pack(), or the .place() functions. We will be using .grid(), it is important to note the rows and columns of the grid do have have any width or height and take on the dimensions of items inside of them. from tkinter import * window = Tk() window.title(\"Amplified Gratings\") label = Label(window, text=\"hello\") label.grid(column=0, row=0) window.mainloop() Our result: Notice the size of the window and grid took the dimensions of the label, and cuts off the title. In order to fix this the window and or label can be given a size. In this example we will do both To better see the dimensions of the label we will add a border. Window minimum dimensions: width = 300 height = 300 window.minsize(width, height) Label dimensions: label = Label(window, text=\"hello\", width=5, height=3, borderwidth=2, relief=SOLID) Code all together: from tkinter import * width = 300 height = 300 window = Tk() window.minsize(width, height) window.title(\"Amplified Gratings\") label = Label(window, text=\"hello\", width=5, height=3, borderwidth=2, relief=SOLID) label.grid(column=0, row=0) window.mainloop() result: Tkinter widgets have many features that can be added to them such as different borders, dimensions, colorsm, x and y padding and text fonts. Part 2 Next we will add a button which changes the text of the Label. When the button is pressed it will call a function which toggles text. When adding functions, and varibale that interact with serveral parts of the GUI is is easiest to create the GUI inside of a class. This is done to allow varibles to be added and changed by different parts of the GUI. To do this I will create a class call MyGUI and paste the gui code we have so far inside of the initializer, aside from the creation of the imports, window, the runloop, and I will add a line to create the class object. To associate varibles with the class object we add \"self.\" in front of them. from tkinter import * class MyGUI: def __init__(self, window): self.labelText = StringVar() self.labelText.set(\"hello\") self.label = Label(window, textvariable = labelText, width=5, height=3, borderwidth=2, relief=SOLID) self.label.grid(column=0, row=0) width = 300 height = 300 window = Tk() window.minsize(width, height) window.title(\"Amplified Gratings\") gui = MyGUI(window) window.mainloop() Now to create the toggle button. First we should create a tkinter StringVar to hold the text for our Label: self.labelText = StringVar() self.labelText.set(\"hello\") Then we should replace the text argument with a textvarible for out label: self.label = Label(window, textvariable = labelText, width=5, height=3, borderwidth=2, relief=SOLID) self.label.grid(column=0, row=0) To add a button we will define a function called pressed_button and add a tkinter button: from tkinter import * class MyGUI: def __init__(self, window): self.labelText = StringVar() self.labelText.set(\"hello\") self.label = Label(window, textvariable = self.labelText, width=5, height=3, borderwidth=2, relief=SOLID) self.label.grid(column=0, row=0) self.button = Button(window, text=\"press\", command=self.pressed_button) self.button.grid(column=1, row=0) def pressed_button(self): if self.labelText.get() == \"begin experiment\": self.labelText.set(\"abort experiment\") else: self.labelText.set(\"begin experiment\") width = 300 height = 300 window = Tk() window.minsize(width, height) window.title(\"Amplified Gratings\") gui = MyGUI(window) window.mainloop() result: First I will change the starting text to say \"begin experiment\" self.labelText.set(\"begin experiment\") The label is very close to the edge and the words get cut off so we will increase the width of the label and create a spacer. and rearrange the widgets in the grid. margin = 2 self.spacer = Label(window, width=margin, height=margin) self.spacer.grid(column=0, row=0) self.label = Label(window, textvariable = self.labelText, width=12, height=2, borderwidth=2, relief=SOLID) self.label.grid(column=1, row=1) result: Part 3 Text feilds are import when designing a GUI. Tkinter provides an Entry widget, which acts as a text box. We will add a label which updates as a text box is filled out. More specifically a password box which uses a label to display the strength of your password. In order to do this we will use a Entry widget, StringVar to keep track of the current text in the box, and a Label to display a message. We will use the trace function on the StringVar to call a function when the entry box is changed. First we add the label saying to enter your password: self.entryLabel = Label(window,text=\"Enter your password:\") self.entryLabel.grid(column=0, row=2) Next we add a StringVar to hold the password and Entry box to type the password in. The trace function will call the checkStrength() function when the StringVar is writen too. self.password = StringVar() self.password.trace(\"w\", lambda name, index, mode, password=self.password:self.checkStrength()) self.entry = Entry(window, textvariable=self.password) self.entry.grid(column=1, row=2) We then create the StringVar for hold the strenth string, and the Label to display it. self.strengthText = StringVar() self.strengthText.set(\"\") self.strengthLabel = Label(window, textvariable=self.strengthText, width = 10) self.strengthLabel.grid(column=2, row=2) Finally we create the checkStrength() function, and decide the strengths that coorespsond to certains length ranges. As an added feature the label will change color based on the strength. def checkStrength(self): length = len(self.password.get()) if length == 0: self.strengthText.set(\"\") self.strengthLabel.config(bg=\"systemWindowBody\") elif length >= 8: self.strengthText.set(\"Strong\") self.strengthLabel.config(bg=\"green3\") elif length >= 6: self.strengthText.set(\"Good\") self.strengthLabel.config(bg=\"gold2\") elif length >= 4: self.strengthText.set(\"ok\") self.strengthLabel.config(bg=\"DarkOrange2\") else: self.strengthText.set(\"Not Accepted\") self.strengthLabel.config(bg=\"red2\") The following is all the code together: from tkinter import * class MyGUI: def __init__(self, window): margin = 2 self.spacer = Label(window, width=margin, height=margin) self.spacer.grid(column=0, row=0) self.labelText = StringVar() self.labelText.set(\"begin experiment\") self.label = Label(window, textvariable = self.labelText, width=12, height=2, borderwidth=2, relief=SOLID) self.label.grid(column=1, row=1) self.button = Button(window, text=\"press\", command=self.pressed_button) self.button.grid(column=2, row=1) self.entryLabel = Label(window,text=\"Enter your password:\") self.entryLabel.grid(column=0, row=2) self.password = StringVar() self.password.trace(\"w\", lambda name, index, mode, password=self.password:self.checkStrength()) self.entry = Entry(window, textvariable=self.password) self.entry.grid(column=1, row=2) self.strengthText = StringVar() self.strengthText.set(\"\") self.strengthLabel = Label(window, textvariable=self.strengthText, width = 10) self.strengthLabel.grid(column=2, row=2) def checkStrength(self): length = len(self.password.get()) if length == 0: self.strengthText.set(\"\") self.strengthLabel.config(bg=\"systemWindowBody\") elif length >= 8: self.strengthText.set(\"Strong\") self.strengthLabel.config(bg=\"green3\") elif length >= 6: self.strengthText.set(\"Good\") self.strengthLabel.config(bg=\"gold2\") elif length >= 4: self.strengthText.set(\"ok\") self.strengthLabel.config(bg=\"DarkOrange2\") else: self.strengthText.set(\"Not Accepted\") self.strengthLabel.config(bg=\"red2\") def pressed_button(self): if self.labelText.get() == \"begin experiment\": self.labelText.set(\"abort experiment\") else: self.labelText.set(\"begin experiment\") width = 300 height = 300 window = Tk() window.minsize(width, height) window.title(\"Amplified Gratings\") gui = MyGUI(window) window.mainloop() The result: Part 4 The final tkinter topic this will touch on are frames. Frames are used mainly to better organize widgets throughout the GUI. Frames can be placed inside of a window, and widgets can be placed in a frame. For example we can create a frame and add a label to it using the following: self.myFrame = Frame(window) self.myFrame.pack() self.label = Label(myFramem, text=\"hello\") self.grid(column=0, row=0) In the demo we have built through out the tutorial I will use two frames to separate the top section and the bottom. This is a good idea because both parts may be relavant to the GUI but are not to each other. To do this I will create a top and bottom frame and change the widgets so they are added to the correct frame when created. As finishing touches I add a border to the frames, make the window wider, position the frames using the .place() function which allows you to place widgets or frames reltive to its container. Final code: from tkinter import * class MyGUI: def __init__(self, window): #Frames self.topFrame = Frame(window, borderwidth=2, relief=SUNKEN) self.topFrame.place(relx = 0.05, rely = 0.15, relwidth = 0.9, relheight = 0.35) self.bottomFrame = Frame(window, borderwidth=2, relief=RAISED) self.bottomFrame.place(relx = 0.05, rely = 0.6, relwidth = 0.9, relheight = 0.35) # Top Frame self.labelText = StringVar() self.labelText.set(\"begin experiment\") margin = 2 self.spacer = Label(self.topFrame, width=margin, height=margin) self.spacer.grid(column=0, row=0) self.label = Label(self.topFrame, textvariable = self.labelText, width=12, height=2, borderwidth=2, relief=SOLID) self.label.grid(column=1, row=1) self.button = Button(self.topFrame, text=\"press\", command=self.pressed_button) self.button.grid(column=2, row=1) # Bottom Frame self.entryLabel = Label(self.bottomFrame,text=\"Enter your password:\") self.entryLabel.grid(column=0, row=0) self.password = StringVar() self.password.trace(\"w\", lambda name, index, mode, password=self.password:self.checkStrength()) self.entry = Entry(self.bottomFrame, textvariable=self.password) self.entry.grid(column=1, row=0) self.strengthText = StringVar() self.strengthText.set(\"\") self.strengthLabel = Label(self.bottomFrame, textvariable=self.strengthText, width = 10) self.strengthLabel.grid(column=2, row=0) def checkStrength(self): length = len(self.password.get()) if length == 0: self.strengthText.set(\"\") self.strengthLabel.config(bg=\"systemWindowBody\") elif length >= 8: self.strengthText.set(\"Strong\") self.strengthLabel.config(bg=\"green3\") elif length >= 6: self.strengthText.set(\"Good\") self.strengthLabel.config(bg=\"gold2\") elif length >= 4: self.strengthText.set(\"ok\") self.strengthLabel.config(bg=\"DarkOrange2\") else: self.strengthText.set(\"Not Accepted\") self.strengthLabel.config(bg=\"red2\") def pressed_button(self): if self.labelText.get() == \"begin experiment\": self.labelText.set(\"abort experiment\") else: self.labelText.set(\"begin experiment\") width = 500 height = 300 window = Tk() window.minsize(width, height) window.title(\"Amplified Gratings\") gui = MyGUI(window) window.mainloop() Result:","title":"Tkinter"},{"location":"Tkinter/#creating-a-gui-using-tkinter","text":"","title":"Creating a GUI using Tkinter"},{"location":"Tkinter/#part-1","text":"Tkinter is a python package that provides resources to create interactive GUIs (graphical user interfaces). There are many resources online which provide tutorials and documentation for Tkinter, the following will be a brief overview and tutorial of a simple Tkinter based GUI. Tkinter is a standard package included in python so no downloads are necessary. To begin we will import the package, which tells python we want to use the resources inside of the Tkinter Package. Once imported we will create a window with the title \u201cAmplified Gratings\u201d. from tkinter import * window = Tk() window.title(\"Amplified Gratings\") window.mainloop() Our result: Next we will add a tkinter widget to the window. Widgets consist of a range of items such as a Labels, Buttons, or text fields. label = Label(window, text=\"hello\") In order to display a widget in the window we have to tell the window where it should be. This can be done using .grid(), .pack(), or the .place() functions. We will be using .grid(), it is important to note the rows and columns of the grid do have have any width or height and take on the dimensions of items inside of them. from tkinter import * window = Tk() window.title(\"Amplified Gratings\") label = Label(window, text=\"hello\") label.grid(column=0, row=0) window.mainloop() Our result: Notice the size of the window and grid took the dimensions of the label, and cuts off the title. In order to fix this the window and or label can be given a size. In this example we will do both To better see the dimensions of the label we will add a border. Window minimum dimensions: width = 300 height = 300 window.minsize(width, height) Label dimensions: label = Label(window, text=\"hello\", width=5, height=3, borderwidth=2, relief=SOLID) Code all together: from tkinter import * width = 300 height = 300 window = Tk() window.minsize(width, height) window.title(\"Amplified Gratings\") label = Label(window, text=\"hello\", width=5, height=3, borderwidth=2, relief=SOLID) label.grid(column=0, row=0) window.mainloop() result: Tkinter widgets have many features that can be added to them such as different borders, dimensions, colorsm, x and y padding and text fonts.","title":"Part 1"},{"location":"Tkinter/#part-2","text":"Next we will add a button which changes the text of the Label. When the button is pressed it will call a function which toggles text. When adding functions, and varibale that interact with serveral parts of the GUI is is easiest to create the GUI inside of a class. This is done to allow varibles to be added and changed by different parts of the GUI. To do this I will create a class call MyGUI and paste the gui code we have so far inside of the initializer, aside from the creation of the imports, window, the runloop, and I will add a line to create the class object. To associate varibles with the class object we add \"self.\" in front of them. from tkinter import * class MyGUI: def __init__(self, window): self.labelText = StringVar() self.labelText.set(\"hello\") self.label = Label(window, textvariable = labelText, width=5, height=3, borderwidth=2, relief=SOLID) self.label.grid(column=0, row=0) width = 300 height = 300 window = Tk() window.minsize(width, height) window.title(\"Amplified Gratings\") gui = MyGUI(window) window.mainloop() Now to create the toggle button. First we should create a tkinter StringVar to hold the text for our Label: self.labelText = StringVar() self.labelText.set(\"hello\") Then we should replace the text argument with a textvarible for out label: self.label = Label(window, textvariable = labelText, width=5, height=3, borderwidth=2, relief=SOLID) self.label.grid(column=0, row=0) To add a button we will define a function called pressed_button and add a tkinter button: from tkinter import * class MyGUI: def __init__(self, window): self.labelText = StringVar() self.labelText.set(\"hello\") self.label = Label(window, textvariable = self.labelText, width=5, height=3, borderwidth=2, relief=SOLID) self.label.grid(column=0, row=0) self.button = Button(window, text=\"press\", command=self.pressed_button) self.button.grid(column=1, row=0) def pressed_button(self): if self.labelText.get() == \"begin experiment\": self.labelText.set(\"abort experiment\") else: self.labelText.set(\"begin experiment\") width = 300 height = 300 window = Tk() window.minsize(width, height) window.title(\"Amplified Gratings\") gui = MyGUI(window) window.mainloop() result: First I will change the starting text to say \"begin experiment\" self.labelText.set(\"begin experiment\") The label is very close to the edge and the words get cut off so we will increase the width of the label and create a spacer. and rearrange the widgets in the grid. margin = 2 self.spacer = Label(window, width=margin, height=margin) self.spacer.grid(column=0, row=0) self.label = Label(window, textvariable = self.labelText, width=12, height=2, borderwidth=2, relief=SOLID) self.label.grid(column=1, row=1) result:","title":"Part 2"},{"location":"Tkinter/#part-3","text":"Text feilds are import when designing a GUI. Tkinter provides an Entry widget, which acts as a text box. We will add a label which updates as a text box is filled out. More specifically a password box which uses a label to display the strength of your password. In order to do this we will use a Entry widget, StringVar to keep track of the current text in the box, and a Label to display a message. We will use the trace function on the StringVar to call a function when the entry box is changed. First we add the label saying to enter your password: self.entryLabel = Label(window,text=\"Enter your password:\") self.entryLabel.grid(column=0, row=2) Next we add a StringVar to hold the password and Entry box to type the password in. The trace function will call the checkStrength() function when the StringVar is writen too. self.password = StringVar() self.password.trace(\"w\", lambda name, index, mode, password=self.password:self.checkStrength()) self.entry = Entry(window, textvariable=self.password) self.entry.grid(column=1, row=2) We then create the StringVar for hold the strenth string, and the Label to display it. self.strengthText = StringVar() self.strengthText.set(\"\") self.strengthLabel = Label(window, textvariable=self.strengthText, width = 10) self.strengthLabel.grid(column=2, row=2) Finally we create the checkStrength() function, and decide the strengths that coorespsond to certains length ranges. As an added feature the label will change color based on the strength. def checkStrength(self): length = len(self.password.get()) if length == 0: self.strengthText.set(\"\") self.strengthLabel.config(bg=\"systemWindowBody\") elif length >= 8: self.strengthText.set(\"Strong\") self.strengthLabel.config(bg=\"green3\") elif length >= 6: self.strengthText.set(\"Good\") self.strengthLabel.config(bg=\"gold2\") elif length >= 4: self.strengthText.set(\"ok\") self.strengthLabel.config(bg=\"DarkOrange2\") else: self.strengthText.set(\"Not Accepted\") self.strengthLabel.config(bg=\"red2\") The following is all the code together: from tkinter import * class MyGUI: def __init__(self, window): margin = 2 self.spacer = Label(window, width=margin, height=margin) self.spacer.grid(column=0, row=0) self.labelText = StringVar() self.labelText.set(\"begin experiment\") self.label = Label(window, textvariable = self.labelText, width=12, height=2, borderwidth=2, relief=SOLID) self.label.grid(column=1, row=1) self.button = Button(window, text=\"press\", command=self.pressed_button) self.button.grid(column=2, row=1) self.entryLabel = Label(window,text=\"Enter your password:\") self.entryLabel.grid(column=0, row=2) self.password = StringVar() self.password.trace(\"w\", lambda name, index, mode, password=self.password:self.checkStrength()) self.entry = Entry(window, textvariable=self.password) self.entry.grid(column=1, row=2) self.strengthText = StringVar() self.strengthText.set(\"\") self.strengthLabel = Label(window, textvariable=self.strengthText, width = 10) self.strengthLabel.grid(column=2, row=2) def checkStrength(self): length = len(self.password.get()) if length == 0: self.strengthText.set(\"\") self.strengthLabel.config(bg=\"systemWindowBody\") elif length >= 8: self.strengthText.set(\"Strong\") self.strengthLabel.config(bg=\"green3\") elif length >= 6: self.strengthText.set(\"Good\") self.strengthLabel.config(bg=\"gold2\") elif length >= 4: self.strengthText.set(\"ok\") self.strengthLabel.config(bg=\"DarkOrange2\") else: self.strengthText.set(\"Not Accepted\") self.strengthLabel.config(bg=\"red2\") def pressed_button(self): if self.labelText.get() == \"begin experiment\": self.labelText.set(\"abort experiment\") else: self.labelText.set(\"begin experiment\") width = 300 height = 300 window = Tk() window.minsize(width, height) window.title(\"Amplified Gratings\") gui = MyGUI(window) window.mainloop() The result:","title":"Part 3"},{"location":"Tkinter/#part-4","text":"The final tkinter topic this will touch on are frames. Frames are used mainly to better organize widgets throughout the GUI. Frames can be placed inside of a window, and widgets can be placed in a frame. For example we can create a frame and add a label to it using the following: self.myFrame = Frame(window) self.myFrame.pack() self.label = Label(myFramem, text=\"hello\") self.grid(column=0, row=0) In the demo we have built through out the tutorial I will use two frames to separate the top section and the bottom. This is a good idea because both parts may be relavant to the GUI but are not to each other. To do this I will create a top and bottom frame and change the widgets so they are added to the correct frame when created. As finishing touches I add a border to the frames, make the window wider, position the frames using the .place() function which allows you to place widgets or frames reltive to its container. Final code: from tkinter import * class MyGUI: def __init__(self, window): #Frames self.topFrame = Frame(window, borderwidth=2, relief=SUNKEN) self.topFrame.place(relx = 0.05, rely = 0.15, relwidth = 0.9, relheight = 0.35) self.bottomFrame = Frame(window, borderwidth=2, relief=RAISED) self.bottomFrame.place(relx = 0.05, rely = 0.6, relwidth = 0.9, relheight = 0.35) # Top Frame self.labelText = StringVar() self.labelText.set(\"begin experiment\") margin = 2 self.spacer = Label(self.topFrame, width=margin, height=margin) self.spacer.grid(column=0, row=0) self.label = Label(self.topFrame, textvariable = self.labelText, width=12, height=2, borderwidth=2, relief=SOLID) self.label.grid(column=1, row=1) self.button = Button(self.topFrame, text=\"press\", command=self.pressed_button) self.button.grid(column=2, row=1) # Bottom Frame self.entryLabel = Label(self.bottomFrame,text=\"Enter your password:\") self.entryLabel.grid(column=0, row=0) self.password = StringVar() self.password.trace(\"w\", lambda name, index, mode, password=self.password:self.checkStrength()) self.entry = Entry(self.bottomFrame, textvariable=self.password) self.entry.grid(column=1, row=0) self.strengthText = StringVar() self.strengthText.set(\"\") self.strengthLabel = Label(self.bottomFrame, textvariable=self.strengthText, width = 10) self.strengthLabel.grid(column=2, row=0) def checkStrength(self): length = len(self.password.get()) if length == 0: self.strengthText.set(\"\") self.strengthLabel.config(bg=\"systemWindowBody\") elif length >= 8: self.strengthText.set(\"Strong\") self.strengthLabel.config(bg=\"green3\") elif length >= 6: self.strengthText.set(\"Good\") self.strengthLabel.config(bg=\"gold2\") elif length >= 4: self.strengthText.set(\"ok\") self.strengthLabel.config(bg=\"DarkOrange2\") else: self.strengthText.set(\"Not Accepted\") self.strengthLabel.config(bg=\"red2\") def pressed_button(self): if self.labelText.get() == \"begin experiment\": self.labelText.set(\"abort experiment\") else: self.labelText.set(\"begin experiment\") width = 500 height = 300 window = Tk() window.minsize(width, height) window.title(\"Amplified Gratings\") gui = MyGUI(window) window.mainloop() Result:","title":"Part 4"}]}